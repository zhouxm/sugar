-- phpMyAdmin SQL Dump
-- version 4.7.0
-- https://www.phpmyadmin.net/
--
-- Host: localhost
-- Generation Time: 2018-05-29 02:39:18
-- 服务器版本： 5.7.18
-- PHP Version: 5.6.30

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET AUTOCOMMIT = 0;
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- Database: `sparkconf`
--

-- --------------------------------------------------------

--
-- 表的结构 `conf`
--

CREATE TABLE `conf` (
  `conf_name` varchar(100) CHARACTER SET ascii COLLATE ascii_bin NOT NULL COMMENT '属性名称',
  `default_value` text CHARACTER SET ascii COLLATE ascii_bin COMMENT '缺省值',
  `conf_desc` text CHARACTER SET ascii COLLATE ascii_bin COMMENT '属性描述',
  `conf_type` int(11) DEFAULT '0'
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

--
-- 转存表中的数据 `conf`
--

INSERT INTO `conf` (`conf_name`, `default_value`, `conf_desc`, `conf_type`) VALUES
('', '', '', 13),
('spark.acls.enable', 'FALSE', 'Whether Spark acls should be enabled. If enabled, this checks to see if the user has access permissions to view or modify the job. Note this requires the user to be known, so if the user comes across as null no checks are done. Filters can be used with the UI to authenticate and set the user.', 11),
('spark.admin.acls', 'Empty', 'Comma separated list of users/administrators that have view and modify access to all Spark jobs. This can be used if you run on a shared cluster and have a set of administrators or devs who help debug when things do not work. Putting a \"*\" in the list means any user can have the privilege of admin.', 11),
('spark.admin.acls.groups', 'Empty', 'Comma separated list of groups that have view and modify access to all Spark jobs. This can be used if you have a set of administrators or developers who help maintain and debug the underlying infrastructure. Putting a \"*\" in the list means any user in any group can have the privilege of admin. The user groups are obtained from the instance of the groups mapping provider specified by?spark.user.groups.mapping. Check the entryspark.user.groups.mapping?for more details.', 11),
('spark.app.name', '(none)', 'The name of your application. This will appear in the UI and in log data.', 1),
('spark.authenticate', 'FALSE', 'Whether Spark authenticates its internal connections. Seespark.authenticate.secret?if not running on YARN.', 11),
('spark.authenticate.enableSaslEncryption', 'FALSE', 'Enable encrypted communication when authentication is enabled. This is supported by the block transfer service and the RPC endpoints.', 11),
('spark.authenticate.secret', 'None', 'Set the secret key used for Spark to authenticate between components. This needs to be set if not running on YARN and authentication is enabled.', 11),
('spark.blacklist.application.fetchFailure.enabled', 'FALSE', '(Experimental) If set to \"true\", Spark will blacklist the executor immediately when a fetch failure happenes. If external shuffle service is enabled, then the whole node will be blacklisted.', 9),
('spark.blacklist.application.maxFailedExecutorsPerNode', '2', '(Experimental) How many different executors must be blacklisted for the entire application, before the node is blacklisted for the entire application. Blacklisted nodes will be automatically added back to the pool of available resources after the timeout specified byspark.blacklist.timeout. Note that with dynamic allocation, though, the executors on the node may get marked as idle and be reclaimed by the cluster manager.', 9),
('spark.blacklist.application.maxFailedTasksPerExecutor', '2', '(Experimental) How many different tasks must fail on one executor, in successful task sets, before the executor is blacklisted for the entire application. Blacklisted executors will be automatically added back to the pool of available resources after the timeout specified byspark.blacklist.timeout. Note that with dynamic allocation, though, the executors may get marked as idle and be reclaimed by the cluster manager.', 9),
('spark.blacklist.enabled', 'FALSE', 'If set to \"true\", prevent Spark from scheduling tasks on executors that have been blacklisted due to too many task failures. The blacklisting algorithm can be further controlled by the other \"spark.blacklist\" configuration options.', 9),
('spark.blacklist.killBlacklistedExecutors', 'FALSE', '(Experimental) If set to \"true\", allow Spark to automatically kill, and attempt to re-create, executors when they are blacklisted. Note that, when an entire node is added to the blacklist, all of the executors on that node will be killed.', 9),
('spark.blacklist.stage.maxFailedExecutorsPerNode', '2', '(Experimental) How many different executors are marked as blacklisted for a given stage, before the entire node is marked as failed for the stage.', 9),
('spark.blacklist.stage.maxFailedTasksPerExecutor', '2', '(Experimental) How many different tasks must fail on one executor, within one stage, before the executor is blacklisted for that stage.', 9),
('spark.blacklist.task.maxTaskAttemptsPerExecutor', '1', '(Experimental) For a given task, how many times it can be retried on one executor before the executor is blacklisted for that task.', 9),
('spark.blacklist.task.maxTaskAttemptsPerNode', '2', '(Experimental) For a given task, how many times it can be retried on one node, before the entire node is blacklisted for that task.', 9),
('spark.blacklist.timeout', '1h', '(Experimental) How long a node or executor is blacklisted for the entire application, before it is unconditionally removed from the blacklist to attempt running new tasks.', 9),
('spark.blockManager.port', '(random)', 'Port for all block managers to listen on. These exist on both the driver and the executors.', 8),
('spark.broadcast.blockSize', '4m', 'Size of each piece of a block for?TorrentBroadcastFactory, in KiB unless otherwise specified. Too large a value decreases parallelism during broadcast (makes it slower); however, if it is too small,?BlockManager?might take a performance hit.', 7),
('spark.broadcast.compress', 'TRUE', 'Whether to compress broadcast variables before sending them. Generally a good idea. Compression will use?spark.io.compression.codec.', 5),
('spark.cleaner.periodicGC.interval', '30min', 'Controls how often to trigger a garbage collection.\n\nThis context cleaner triggers cleanups only when weak references are garbage collected. In long-running applications with large driver JVMs, where there is little memory pressure on the driver, this may happen very occasionally or not at all. Not cleaning at all may lead to executors running out of disk space after a while.', 6),
('spark.cleaner.referenceTracking', 'TRUE', 'Enables or disables context cleaning.', 6),
('spark.cleaner.referenceTracking.blocking', 'TRUE', 'Controls whether the cleaning thread should block on cleanup tasks (other than shuffle, which is controlled byspark.cleaner.referenceTracking.blocking.shuffle?Spark property).', 6),
('spark.cleaner.referenceTracking.blocking.shuffle', 'FALSE', 'Controls whether the cleaning thread should block on shuffle cleanup tasks.', 6),
('spark.cleaner.referenceTracking.cleanCheckpoints', 'FALSE', 'Controls whether to clean checkpoint files if the reference is out of scope.', 6),
('spark.core.connection.ack.wait.timeout', 'spark.network.timeout', 'How long for the connection to wait for ack to occur before timing out and giving up. To avoid unwilling timeout caused by long pause like GC, you can set larger value.', 11),
('spark.cores.max', '(not set)', 'When running on a?standalone deploy cluster?or a?Mesos cluster in \"coarse-grained\" sharing mode, the maximum amount of CPU cores to request for the application from across the cluster (not from each machine). If not set, the default will be?spark.deploy.defaultCores?on Spark\'s standalone cluster manager, or infinite (all available cores) on Mesos.', 9),
('spark.default.parallelism', 'For distributed shuffle operations like?reduceByKeyand?join, the largest number of partitions in a parent RDD. For operations like?parallelizewith no parent RDDs, it depends on the cluster manager:\nLocal mode: number of cores on the local machine\nMesos fine grained mode: 8\nOthers: total number of cores on all executor nodes or 2, whichever is larger', 'Default number of partitions in RDDs returned by transformations like?join,?reduceByKey, and?parallelize?when not set by user.', 7),
('spark.deploy.recoveryMode', 'NONE', 'The recovery mode setting to recover submitted Spark jobs with cluster mode when it failed and relaunches. This is only applicable for cluster mode when running with Standalone or Mesos.', 17),
('spark.deploy.zookeeper.dir', 'None', 'When `spark.deploy.recoveryMode` is set to ZOOKEEPER, this configuration is used to set the zookeeper directory to store recovery state.', 17),
('spark.deploy.zookeeper.url', 'None', 'When `spark.deploy.recoveryMode` is set to ZOOKEEPER, this configuration is used to set the zookeeper URL to connect to.', 17),
('spark.driver.bindAddress', '(value of spark.driver.host)', 'Hostname or IP address where to bind listening sockets. This config overrides the SPARK_LOCAL_IP environment variable (see below).?\nIt also allows a different address from the local one to be advertised to executors or external systems. This is useful, for example, when running containers with bridged networking. For this to properly work, the different ports used by the driver (RPC, block manager and UI) need to be forwarded from the container\'s host.', 8),
('spark.driver.blockManager.port', '(value of spark.blockManager.port)', 'Driver-specific port for the block manager to listen on, for cases where it cannot use the same configuration as executors.', 8),
('spark.driver.cores', '1', 'Number of cores to use for the driver process, only in cluster mode.', 1),
('spark.driver.extraClassPath', '(none)', 'Extra classpath entries to prepend to the classpath of the driver.?\nNote:?In client mode, this config must not be set through the?SparkConf?directly in your application, because the driver JVM has already started at that point. Instead, please set this through the?--driver-class-path?command line option or in your default properties file.', 2),
('spark.driver.extraJavaOptions', '(none)', 'A string of extra JVM options to pass to the driver. For instance, GC settings or other logging. Note that it is illegal to set maximum heap size (-Xmx) settings with this option. Maximum heap size settings can be set with?spark.driver.memory?in the cluster mode and through the?--driver-memory?command line option in the client mode.?\nNote:?In client mode, this config must not be set through the?SparkConf?directly in your application, because the driver JVM has already started at that point. Instead, please set this through the?--driver-java-options?command line option or in your default properties file.', 2),
('spark.driver.extraLibraryPath', '(none)', 'Set a special library path to use when launching the driver JVM.?\nNote:?In client mode, this config must not be set through the?SparkConf?directly in your application, because the driver JVM has already started at that point. Instead, please set this through the?--driver-library-path?command line option or in your default properties file.', 2),
('spark.driver.host', '(local hostname)', 'Hostname or IP address for the driver. This is used for communicating with the executors and the standalone Master.', 8),
('spark.driver.maxResultSize', '1g', 'Limit of total size of serialized results of all partitions for each Spark action (e.g. collect) in bytes. Should be at least 1M, or 0 for unlimited. Jobs will be aborted if the total size is above this limit. Having a high limit may cause out-of-memory errors in driver (depends on spark.driver.memory and memory overhead of objects in JVM). Setting a proper limit can protect the driver from out-of-memory errors.', 1),
('spark.driver.memory', '1g', 'Amount of memory to use for the driver process, i.e. where SparkContext is initialized, in MiB unless otherwise specified (e.g. 1g, 2g).\r\nNote: In client mode, this config must not be set through the?SparkConf?directly in your application, because the driver JVM has already started at that point. Instead, please set this through the?--driver-memory?command line option or in your default properties file.', 1),
('spark.driver.memoryOverhead', 'driverMemory * 0.10, with minimum of 384', 'The amount of off-heap memory to be allocated per driver in cluster mode, in MiB unless otherwise specified. This is memory that accounts for things like VM overheads, interned strings, other native overheads, etc. This tends to grow with the container size (typically 6-10%). This option is currently supported on YARN and Kubernetes.', 1),
('spark.driver.port', '(random)', 'Port for the driver to listen on. This is used for communicating with the executors and the standalone Master.', 8),
('spark.driver.supervise', 'FALSE', 'If true, restarts the driver automatically if it fails with a non-zero exit status. Only has effect in Spark standalone mode or Mesos cluster deploy mode.', 1),
('spark.driver.userClassPathFirst', 'FALSE', '(Experimental) Whether to give user-added jars precedence over Spark\'s own jars when loading classes in the driver. This feature can be used to mitigate conflicts between Spark\'s dependencies and user dependencies. It is currently an experimental feature. This is used in cluster mode only.', 2),
('spark.dynamicAllocation.cachedExecutorIdleTimeout', 'infinity', 'If dynamic allocation is enabled and an executor which has cached data blocks has been idle for more than this duration, the executor will be removed. For more details, see this?description.', 10),
('spark.dynamicAllocation.enabled', 'FALSE', 'Whether to use dynamic resource allocation, which scales the number of executors registered with this application up and down based on the workload. For more detail, see the description?here.?\n\nThis requires?spark.shuffle.service.enabled?to be set. The following configurations are also relevant:spark.dynamicAllocation.minExecutors,spark.dynamicAllocation.maxExecutors, andspark.dynamicAllocation.initialExecutors', 10),
('spark.dynamicAllocation.executorIdleTimeout', '60s', 'If dynamic allocation is enabled and an executor has been idle for more than this duration, the executor will be removed. For more detail, see this?description.', 10),
('spark.dynamicAllocation.initialExecutors', 'spark.dynamicAllocation.minExecutors', 'Initial number of executors to run if dynamic allocation is enabled.?\n\nIf `--num-executors` (or `spark.executor.instances`) is set and larger than this value, it will be used as the initial number of executors.', 10),
('spark.dynamicAllocation.maxExecutors', 'infinity', 'Upper bound for the number of executors if dynamic allocation is enabled.', 10),
('spark.dynamicAllocation.minExecutors', '0', 'Lower bound for the number of executors if dynamic allocation is enabled.', 10),
('spark.dynamicAllocation.schedulerBacklogTimeout', '1s', 'If dynamic allocation is enabled and there have been pending tasks backlogged for more than this duration, new executors will be requested. For more detail, see this?description.', 10),
('spark.dynamicAllocation.sustainedSchedulerBacklogTimeout', 'schedulerBacklogTimeout', 'Same as?spark.dynamicAllocation.schedulerBacklogTimeout, but used only for subsequent executor requests. For more detail, see this?description.', 10),
('spark.eventLog.buffer.kb', '100k', 'Buffer size to use when writing to output streams, in KiB unless otherwise specified.', 4),
('spark.eventLog.compress', 'FALSE', 'Whether to compress logged events, if?spark.eventLog.enabled?is true. Compression will use?spark.io.compression.codec.', 4),
('spark.eventLog.dir', 'file:///tmp/spark-events', 'Base directory in which Spark events are logged, if?spark.eventLog.enabledis true. Within this base directory, Spark creates a sub-directory for each application, and logs the events specific to the application in this directory. Users may want to set this to a unified location like an HDFS directory so history files can be read by the history server.', 4),
('spark.eventLog.enabled', 'FALSE', 'Whether to log Spark events, useful for reconstructing the Web UI after the application has finished.', 4),
('spark.eventLog.logBlockUpdates.enabled', 'FALSE', 'Whether to log events for every block update, if?spark.eventLog.enabled?is true. *Warning*: This will increase the size of the event log considerably.', 4),
('spark.eventLog.overwrite', 'FALSE', 'Whether to overwrite any existing files.', 4),
('spark.executor.cores', '1 in YARN mode, all the available cores on the worker in standalone and Mesos coarse-grained modes.', 'The number of cores to use on each executor. In standalone and Mesos coarse-grained modes, for more detail, see?this description.', 7),
('spark.executor.extraClassPath', '(none)', 'Extra classpath entries to prepend to the classpath of executors. This exists primarily for backwards-compatibility with older versions of Spark. Users typically should not need to set this option.', 2),
('spark.executor.extraJavaOptions', '(none)', 'A string of extra JVM options to pass to executors. For instance, GC settings or other logging. Note that it is illegal to set Spark properties or maximum heap size (-Xmx) settings with this option. Spark properties should be set using a SparkConf object or the spark-defaults.conf file used with the spark-submit script. Maximum heap size settings can be set with spark.executor.memory.', 2),
('spark.executor.extraLibraryPath', '(none)', 'Set a special library path to use when launching executor JVM\'s.', 2),
('spark.executor.heartbeatInterval', '10s', 'Interval between each executor\'s heartbeats to the driver. Heartbeats let the driver know that the executor is still alive and update it with metrics for in-progress tasks. spark.executor.heartbeatInterval should be significantly less than spark.network.timeout', 7),
('spark.executor.instances', '2', 'The number of executors for static allocation. With?spark.dynamicAllocation.enabled, the initial set of executors will be at least this large.', 18),
('spark.executor.logs.rolling.enableCompression', 'FALSE', 'Enable executor log compression. If it is enabled, the rolled executor logs will be compressed. Disabled by default.', 2),
('spark.executor.logs.rolling.maxRetainedFiles', '(none)', 'Sets the number of latest rolling log files that are going to be retained by the system. Older log files will be deleted. Disabled by default.', 2),
('spark.executor.logs.rolling.maxSize', '(none)', 'Set the max size of the file in bytes by which the executor logs will be rolled over. Rolling is disabled by default. See?spark.executor.logs.rolling.maxRetainedFiles?for automatic cleaning of old logs.', 2),
('spark.executor.logs.rolling.strategy', '(none)', 'Set the strategy of rolling of executor logs. By default it is disabled. It can be set to \"time\" (time-based rolling) or \"size\" (size-based rolling). For \"time\", use?spark.executor.logs.rolling.time.interval?to set the rolling interval. For \"size\", use?spark.executor.logs.rolling.maxSize?to set the maximum file size for rolling.', 2),
('spark.executor.logs.rolling.time.interval', 'daily', 'Set the time interval by which the executor logs will be rolled over. Rolling is disabled by default. Valid values are?daily,?hourly,?minutely?or any interval in seconds. See?spark.executor.logs.rolling.maxRetainedFiles?for automatic cleaning of old logs.', 2),
('spark.executor.memory', '1g', 'Amount of memory to use per executor process, in MiB unless otherwise specified. (e.g. 2g, 8g).', 1),
('spark.executor.memoryOverhead', 'executorMemory * 0.10, with minimum of 384', 'The amount of off-heap memory to be allocated per executor, in MiB unless otherwise specified. This is memory that accounts for things like VM overheads, interned strings, other native overheads, etc. This tends to grow with the executor size (typically 6-10%). This option is currently supported on YARN and Kubernetes.', 1),
('spark.executor.userClassPathFirst', 'FALSE', '(Experimental) Same functionality as?spark.driver.userClassPathFirst, but applied to executor instances.', 2),
('spark.executorEnv.[EnvironmentVariableName]', '(none)', 'Add the environment variable specified by?EnvironmentVariableName?to the Executor process. The user can specify multiple of these to set multiple environment variables.', 2),
('spark.extraListeners', '(none)', 'A comma-separated list of classes that implement?SparkListener; when initializing SparkContext, instances of these classes will be created and registered with Spark\'s listener bus. If a class has a single-argument constructor that accepts a SparkConf, that constructor will be called; otherwise, a zero-argument constructor will be called. If no valid constructor can be found, the SparkContext creation will fail with an exception.', 1),
('spark.files', '', 'Comma-separated list of files to be placed in the working directory of each executor. Globs are allowed.', 2),
('spark.files.fetchTimeout', '60s', 'Communication timeout to use when fetching files added through SparkContext.addFile() from the driver.', 7),
('spark.files.maxPartitionBytes', '134217728 (128 MB)', 'The maximum number of bytes to pack into a single partition when reading files.', 7),
('spark.files.openCostInBytes', '4194304 (4 MB)', 'The estimated cost to open a file, measured by the number of bytes could be scanned at the same time. This is used when putting multiple files into a partition. It is better to over estimate, then the partitions with small files will be faster than partitions with bigger files.', 7),
('spark.files.overwrite', 'FALSE', 'Whether to overwrite files added through SparkContext.addFile() when the target file exists and its contents do not match those of the source.', 7),
('spark.files.useFetchCache', 'TRUE', 'If set to true (default), file fetching will use a local cache that is shared by executors that belong to the same application, which can improve task launching performance when running many executors on the same host. If set to false, these caching optimizations will be disabled and all executors will fetch their own copies of files. This optimization may be disabled in order to use Spark local directories that reside on NFS filesystems (see?SPARK-6313?for more details).', 7),
('spark.graphx.pregel.checkpointInterval', '-1', 'Checkpoint interval for graph and message in Pregel. It used to avoid stackOverflowError due to long lineage chains after lots of iterations. The checkpoint is disabled by default.', 16),
('spark.hadoop.cloneConf', 'FALSE', 'If set to true, clones a new Hadoop?Configurationobject for each task. This option should be enabled to work around?Configuration?thread-safety issues (see?SPARK-2546?for more details). This is disabled by default in order to avoid unexpected performance regressions for jobs that are not affected by these issues.', 7),
('spark.hadoop.mapreduce.fileoutputcommitter.algorithm.version', '1', 'The file output committer algorithm version, valid algorithm version number: 1 or 2. Version 2 may have better performance, but version 1 may handle failures better in certain situations, as per?MAPREDUCE-4815.', 7),
('spark.hadoop.validateOutputSpecs', 'TRUE', 'If set to true, validates the output specification (e.g. checking if the output directory already exists) used in saveAsHadoopFile and other variants. This can be disabled to silence exceptions due to pre-existing output directories. We recommend that users do not disable this except if trying to achieve compatibility with previous versions of Spark. Simply use Hadoop\'s FileSystem API to delete output directories by hand. This setting is ignored for jobs generated through Spark Streaming\'s StreamingContext, since data may need to be rewritten to pre-existing output directories during checkpoint recovery.', 7),
('spark.io.compression.codec', 'lz4', 'The codec used to compress internal data such as RDD partitions, event log, broadcast variables and shuffle outputs. By default, Spark provides three codecs:?lz4,?lzf, and?snappy. You can also use fully qualified class names to specify the codec, e.g.org.apache.spark.io.LZ4CompressionCodec,org.apache.spark.io.LZFCompressionCodec,org.apache.spark.io.SnappyCompressionCodec, and?org.apache.spark.io.ZstdCompressionCodec.', 5),
('spark.io.compression.lz4.blockSize', '32k', 'Block size in bytes used in LZ4 compression, in the case when LZ4 compression codec is used. Lowering this block size will also lower shuffle memory usage when LZ4 is used.', 5),
('spark.io.compression.snappy.blockSize', '32k', 'Block size in bytes used in Snappy compression, in the case when Snappy compression codec is used. Lowering this block size will also lower shuffle memory usage when Snappy is used.', 5),
('spark.io.compression.zstd.bufferSize', '32k', 'Buffer size in bytes used in Zstd compression, in the case when Zstd compression codec is used. Lowering this size will lower the shuffle memory usage when Zstd is used, but it might increase the compression cost because of excessive JNI call overhead.', 5),
('spark.io.compression.zstd.level', '1', 'Compression level for Zstd compression codec. Increasing the compression level will result in better compression at the expense of more CPU and memory.', 5),
('spark.io.encryption.enabled', 'FALSE', 'Enable IO encryption. Currently supported by all modes except Mesos. It\'s recommended that RPC encryption be enabled when using this feature.', 3),
('spark.io.encryption.keySizeBits', '128', 'IO encryption key size in bits. Supported values are 128, 192 and 256.', 3),
('spark.io.encryption.keygen.algorithm', 'HmacSHA1', 'The algorithm to use when generating the IO encryption key. The supported algorithms are described in the KeyGenerator section of the Java Cryptography Architecture Standard Algorithm Name Documentation.', 3),
('spark.jars', '', 'Comma-separated list of jars to include on the driver and executor classpaths. Globs are allowed.', 2),
('spark.jars.excludes', '', 'Comma-separated list of groupId:artifactId, to exclude while resolving the dependencies provided in?spark.jars.packages?to avoid dependency conflicts.', 2),
('spark.jars.ivy', '', 'Path to specify the Ivy user directory, used for the local Ivy cache and package files from?spark.jars.packages. This will override the Ivy property?ivy.default.ivy.user.dir?which defaults to ~/.ivy2.', 2),
('spark.jars.ivySettings', '', 'Path to an Ivy settings file to customize resolution of jars specified using?spark.jars.packages?instead of the built-in defaults, such as maven central. Additional repositories given by the command-line option?--repositories?or?spark.jars.repositories?will also be included. Useful for allowing Spark to resolve artifacts from behind a firewall e.g. via an in-house artifact server like Artifactory. Details on the settings file format can be found at http://ant.apache.org/ivy/history/latest-milestone/settings.html', 2),
('spark.jars.packages', '', 'Comma-separated list of Maven coordinates of jars to include on the driver and executor classpaths. The coordinates should be groupId:artifactId:version. If?spark.jars.ivySettings?is given artifacts will be resolved according to the configuration in the file, otherwise artifacts will be searched for in the local maven repo, then maven central and finally any additional remote repositories given by the command-line option?--repositories. For more details, seeAdvanced Dependency Management.', 2),
('spark.jars.repositories', '', 'Comma-separated list of additional remote repositories to search for the maven coordinates given with?--packages?or?spark.jars.packages.', 2),
('spark.kryo.classesToRegister', '(none)', 'If you use Kryo serialization, give a comma-separated list of custom class names to register with Kryo. See the?tuning guide?for more details.', 5),
('spark.kryo.referenceTracking', 'TRUE', 'Whether to track references to the same object when serializing data with Kryo, which is necessary if your object graphs have loops and useful for efficiency if they contain multiple copies of the same object. Can be disabled to improve performance if you know this is not the case.', 5),
('spark.kryo.registrationRequired', 'FALSE', 'Whether to require registration with Kryo. If set to \'true\', Kryo will throw an exception if an unregistered class is serialized. If set to false (the default), Kryo will write unregistered class names along with each object. Writing class names can cause significant performance overhead, so enabling this option can enforce strictly that a user has not omitted classes from registration.', 5),
('spark.kryo.registrator', '(none)', 'If you use Kryo serialization, give a comma-separated list of classes that register your custom classes with Kryo. This property is useful if you need to register your classes in a custom way, e.g. to specify a custom field serializer. Otherwise?spark.kryo.classesToRegister?is simpler. It should be set to classes that extend?KryoRegistrator. See the?tuning guide?for more details.', 5),
('spark.kryo.unsafe', 'FALSE', 'Whether to use unsafe based Kryo serializer. Can be substantially faster by using Unsafe Based IO.', 5),
('spark.kryoserializer.buffer', '64k', 'Initial size of Kryo\'s serialization buffer, in KiB unless otherwise specified. Note that there will be one buffer?per core?on each worker. This buffer will grow up tospark.kryoserializer.buffer.max?if needed.', 5),
('spark.kryoserializer.buffer.max', '64m', 'Maximum allowable size of Kryo serialization buffer, in MiB unless otherwise specified. This must be larger than any object you attempt to serialize and must be less than 2048m. Increase this if you get a \"buffer limit exceeded\" exception inside Kryo.', 5),
('spark.kubernetes.allocation.batch.delay', '1s', 'Time to wait between each round of executor pod allocation. Specifying values less than 1 second may lead to excessive CPU usage on the spark driver.', 20),
('spark.kubernetes.allocation.batch.size', '5', 'Number of pods to launch at once in each round of executor pod allocation.', 20),
('spark.kubernetes.authenticate.driver.caCertFile', '(none)', 'Path to the CA cert file for connecting to the Kubernetes API server over TLS from the driver pod when requesting executors. This file must be located on the submitting machine\'s disk, and will be uploaded to the driver pod. Specify this as a path as opposed to a URI (i.e. do not provide a scheme).', 20),
('spark.kubernetes.authenticate.driver.clientCertFile', '(none)', 'Path to the client cert file for authenticating against the Kubernetes API server from the driver pod when requesting executors. This file must be located on the submitting machine\'s disk, and will be uploaded to the driver pod. Specify this as a path as opposed to a URI (i.e. do not provide a scheme).', 20),
('spark.kubernetes.authenticate.driver.clientKeyFile', '(none)', 'Path to the client key file for authenticating against the Kubernetes API server from the driver pod when requesting executors. This file must be located on the submitting machine\'s disk, and will be uploaded to the driver pod. Specify this as a path as opposed to a URI (i.e. do not provide a scheme). If this is specified, it is highly recommended to set up TLS for the driver submission server, as this value is sensitive information that would be passed to the driver pod in plaintext otherwise.', 20),
('spark.kubernetes.authenticate.driver.mounted.caCertFile', '(none)', 'Path to the CA cert file for connecting to the Kubernetes API server over TLS from the driver pod when requesting executors. This path must be accessible from the driver pod. Specify this as a path as opposed to a URI (i.e. do not provide a scheme).', 20),
('spark.kubernetes.authenticate.driver.mounted.clientCertFile', '(none)', 'Path to the client cert file for authenticating against the Kubernetes API server from the driver pod when requesting executors. This path must be accessible from the driver pod. Specify this as a path as opposed to a URI (i.e. do not provide a scheme).', 20),
('spark.kubernetes.authenticate.driver.mounted.clientKeyFile', '(none)', 'Path to the client key file for authenticating against the Kubernetes API server from the driver pod when requesting executors. This path must be accessible from the driver pod. Specify this as a path as opposed to a URI (i.e. do not provide a scheme).', 20),
('spark.kubernetes.authenticate.driver.mounted.oauthTokenFile', '(none)', 'Path to the file containing the OAuth token to use when authenticating against the Kubernetes API server from the driver pod when requesting executors. This path must be accessible from the driver pod. Note that unlike the other authentication options, this file must contain the exact string value of the token to use for the authentication.', 20),
('spark.kubernetes.authenticate.driver.oauthToken', '(none)', 'OAuth token to use when authenticating against the Kubernetes API server from the driver pod when requesting executors. Note that unlike the other authentication options, this must be the exact string value of the token to use for the authentication. This token value is uploaded to the driver pod. If this is specified, it is highly recommended to set up TLS for the driver submission server, as this value is sensitive information that would be passed to the driver pod in plaintext otherwise.', 20),
('spark.kubernetes.authenticate.driver.oauthTokenFile', '(none)', 'Path to the OAuth token file containing the token to use when authenticating against the Kubernetes API server from the driver pod when requesting executors. Note that unlike the other authentication options, this file must contain the exact string value of the token to use for the authentication. This token value is uploaded to the driver pod. If this is specified, it is highly recommended to set up TLS for the driver submission server, as this value is sensitive information that would be passed to the driver pod in plaintext otherwise.', 20),
('spark.kubernetes.authenticate.driver.serviceAccountName', 'default', 'Service account that is used when running the driver pod. The driver pod uses this service account when requesting executor pods from the API server. Note that this cannot be specified alongside a CA cert file, client key file, client cert file, and/or OAuth token.', 20),
('spark.kubernetes.authenticate.submission.caCertFile', '(none)', 'Path to the CA cert file for connecting to the Kubernetes API server over TLS when starting the driver. This file must be located on the submitting machine\'s disk. Specify this as a path as opposed to a URI (i.e. do not provide a scheme).', 20),
('spark.kubernetes.authenticate.submission.clientCertFile', '(none)', 'Path to the client cert file for authenticating against the Kubernetes API server when starting the driver. This file must be located on the submitting machine\'s disk. Specify this as a path as opposed to a URI (i.e. do not provide a scheme).', 20),
('spark.kubernetes.authenticate.submission.clientKeyFile', '(none)', 'Path to the client key file for authenticating against the Kubernetes API server when starting the driver. This file must be located on the submitting machine\'s disk. Specify this as a path as opposed to a URI (i.e. do not provide a scheme).', 20),
('spark.kubernetes.authenticate.submission.oauthToken', '(none)', 'OAuth token to use when authenticating against the Kubernetes API server when starting the driver. Note that unlike the other authentication options, this is expected to be the exact string value of the token to use for the authentication.', 20),
('spark.kubernetes.authenticate.submission.oauthTokenFile', '(none)', 'Path to the OAuth token file containing the token to use when authenticating against the Kubernetes API server when starting the driver. This file must be located on the submitting machine\'s disk. Specify this as a path as opposed to a URI (i.e. do not provide a scheme).', 20),
('spark.kubernetes.container.image', '(none)', 'Container image to use for the Spark application. This is usually of the form?example.com/repo/spark:v1.0.0. This configuration is required and must be provided by the user, unless explicit images are provided for each different container type.', 20),
('spark.kubernetes.container.image.pullPolicy', 'IfNotPresent', 'Container image pull policy used when pulling images within Kubernetes.', 20),
('spark.kubernetes.driver.annotation.[AnnotationName]', '(none)', 'Add the annotation specified by?AnnotationName?to the driver pod. For example,?spark.kubernetes.driver.annotation.something=true.', 20),
('spark.kubernetes.driver.container.image', '(value of spark.kubernetes.container.image)', 'Custom container image to use for the driver.', 20),
('spark.kubernetes.driver.label.[LabelName]', '(none)', 'Add the label specified by?LabelName?to the driver pod. For example,?spark.kubernetes.driver.label.something=true. Note that Spark also adds its own labels to the driver pod for bookkeeping purposes.', 20),
('spark.kubernetes.driver.limit.cores', '(none)', 'Specify the hard CPU [limit](https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#resource-requests-and-limits-of-pod-and-container) for the driver pod.', 20),
('spark.kubernetes.driver.pod.name', '(none)', 'Name of the driver pod. If not set, the driver pod name is set to \"spark.app.name\" suffixed by the current timestamp to avoid name conflicts.', 20),
('spark.kubernetes.driver.secrets.[SecretName]', '(none)', 'Add the?Kubernetes Secret?named?SecretName?to the driver pod on the path specified in the value. For example,spark.kubernetes.driver.secrets.spark-secret=/etc/secrets. Note that if an init-container is used, the secret will also be added to the init-container in the driver pod.', 20),
('spark.kubernetes.driverEnv.[EnvironmentVariableName]', '(none)', 'Add the environment variable specified by?EnvironmentVariableName?to the Driver process. The user can specify multiple of these to set multiple environment variables.', 20),
('spark.kubernetes.executor.annotation.[AnnotationName]', '(none)', 'Add the annotation specified by?AnnotationName?to the executor pods. For example,?spark.kubernetes.executor.annotation.something=true.', 20),
('spark.kubernetes.executor.container.image', '(value of spark.kubernetes.container.image)', 'Custom container image to use for executors.', 20),
('spark.kubernetes.executor.label.[LabelName]', '(none)', 'Add the label specified by?LabelName?to the executor pods. For example,?spark.kubernetes.executor.label.something=true. Note that Spark also adds its own labels to the driver pod for bookkeeping purposes.', 20),
('spark.kubernetes.executor.limit.cores', '(none)', 'Specify the hard CPU [limit](https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/#resource-requests-and-limits-of-pod-and-container) for each executor pod launched for the Spark Application.', 20),
('spark.kubernetes.executor.lostCheck.maxAttempts', '10', 'Number of times that the driver will try to ascertain the loss reason for a specific executor. The loss reason is used to ascertain whether the executor failure is due to a framework or an application error which in turn decides whether the executor is removed and replaced, or placed into a failed state for debugging.', 20),
('spark.kubernetes.executor.secrets.[SecretName]', '(none)', 'Add the?Kubernetes Secret?named?SecretName?to the executor pod on the path specified in the value. For example,?spark.kubernetes.executor.secrets.spark-secret=/etc/secrets. Note that if an init-container is used, the secret will also be added to the init-container in the executor pod.', 20),
('spark.kubernetes.initContainer.image', '(value of spark.kubernetes.container.image)', 'Custom container image for the init container of both driver and executors.', 20),
('spark.kubernetes.mountDependencies.filesDownloadDir', '/var/spark-data/spark-files', 'Location to download jars to in the driver and executors. This directory must be empty and will be mounted as an empty directory volume on the driver and executor pods.', 20),
('spark.kubernetes.mountDependencies.jarsDownloadDir', '/var/spark-data/spark-jars', 'Location to download jars to in the driver and executors. This directory must be empty and will be mounted as an empty directory volume on the driver and executor pods.', 20),
('spark.kubernetes.mountDependencies.maxSimultaneousDownloads', '5', 'Maximum number of remote dependencies to download simultaneously in a driver or executor pod.', 20),
('spark.kubernetes.mountDependencies.timeout', '300s', 'Timeout in seconds before aborting the attempt to download and unpack dependencies from remote locations into the driver and executor pods.', 20),
('spark.kubernetes.namespace', 'default', 'The namespace that will be used for running the driver and executor pods.', 20),
('spark.kubernetes.node.selector.[labelKey]', '(none)', 'Adds to the node selector of the driver pod and executor pods, with key?labelKey?and the value as the configuration\'s value. For example, setting?spark.kubernetes.node.selector.identifier?to?myIdentifier?will result in the driver pod and executors having a node selector with key?identifier?and valuemyIdentifier. Multiple node selector keys can be added by setting multiple configurations with this prefix.', 20),
('spark.kubernetes.report.interval', '1s', 'Interval between reports of the current Spark job status in cluster mode.', 20),
('spark.kubernetes.submission.waitAppCompletion', 'TRUE', 'In cluster mode, whether to wait for the application to finish before exiting the launcher process. When changed to false, the launcher has a \"fire-and-forget\" behavior when launching the Spark job.', 20),
('spark.local.dir', '/tmp', 'Directory to use for \"scratch\" space in Spark, including map output files and RDDs that get stored on disk. This should be on a fast, local disk in your system. It can also be a comma-separated list of multiple directories on different disks. NOTE: In Spark 1.0 and later this will be overridden by SPARK_LOCAL_DIRS (Standalone, Mesos) or LOCAL_DIRS (YARN) environment variables set by the cluster manager.', 1),
('spark.locality.wait', '3s', 'How long to wait to launch a data-local task before giving up and launching it on a less-local node. The same wait will be used to step through multiple locality levels (process-local, node-local, rack-local and then any). It is also possible to customize the waiting time for each level by setting?spark.locality.wait.node, etc. You should increase this setting if your tasks are long and see poor locality, but the default usually works well.', 9),
('spark.locality.wait.node', 'spark.locality.wait', 'Customize the locality wait for node locality. For example, you can set this to 0 to skip node locality and search immediately for rack locality (if your cluster has rack information).', 9),
('spark.locality.wait.process', 'spark.locality.wait', 'Customize the locality wait for process locality. This affects tasks that attempt to access cached data in a particular executor process.', 9),
('spark.locality.wait.rack', 'spark.locality.wait', 'Customize the locality wait for rack locality.', 9),
('spark.log.callerContext', '(none)', 'Application information that will be written into Yarn RM log/HDFS audit log when running on Yarn/HDFS. Its length depends on the Hadoop configuration?hadoop.caller.context.max.size. It should be concise, and typically can have up to 50 characters.', 1),
('spark.logConf', 'FALSE', 'Logs the effective SparkConf as INFO when a SparkContext is started.', 1),
('spark.master', '(none)', 'The cluster manager to connect to. See the list of?allowed master URL\'s.', 1),
('spark.maxRemoteBlockSizeFetchToMem', 'Long.MaxValue', 'The remote block will be fetched to disk when size of the block is above this threshold in bytes. This is to avoid a giant request takes too much memory. We can enable this config by setting a specific value(e.g. 200m). Note this configuration will affect both shuffle fetch and block manager remote block fetch. For users who enabled external shuffle service, this feature can only be worked when external shuffle service is newer than Spark 2.2.', 3),
('spark.memory.fraction', '0.6', 'Fraction of (heap space - 300MB) used for execution and storage. The lower this is, the more frequently spills and cached data eviction occur. The purpose of this config is to set aside memory for internal metadata, user data structures, and imprecise size estimation in the case of sparse, unusually large records. Leaving this at the default value is recommended. For more detail, including important information about correctly tuning JVM garbage collection when increasing this value, see?this description.', 6),
('spark.memory.offHeap.enabled', 'FALSE', 'If true, Spark will attempt to use off-heap memory for certain operations. If off-heap memory use is enabled, then?spark.memory.offHeap.size?must be positive.', 6),
('spark.memory.offHeap.size', '0', 'The absolute amount of memory in bytes which can be used for off-heap allocation. This setting has no impact on heap memory usage, so if your executors\' total memory consumption must fit within some hard limit then be sure to shrink your JVM heap size accordingly. This must be set to a positive value when?spark.memory.offHeap.enabled=true.', 6),
('spark.memory.storageFraction', '0.5', 'Amount of storage memory immune to eviction, expressed as a fraction of the size of the region set aside by?spark.memory.fraction. The higher this is, the less working memory may be available to execution and tasks may spill to disk more often. Leaving this at the default value is recommended. For more detail, see?this description.', 6),
('spark.memory.useLegacyMode', 'FALSE', 'Whether to enable the legacy memory management mode used in Spark 1.5 and before. The legacy mode rigidly partitions the heap space into fixed-size regions, potentially leading to excessive spilling if the application was not tuned. The following deprecated memory fraction configurations are not read unless this is enabled:?spark.shuffle.memoryFraction\nspark.storage.memoryFraction\nspark.storage.unrollFraction', 6),
('spark.mesos.coarse', 'TRUE', 'If set to?true, runs over Mesos clusters in \"coarse-grained\" sharing mode, where Spark acquires one long-lived Mesos task on each machine. If set to?false, runs over Mesos cluster in \"fine-grained\" sharing mode, where one Mesos task is created per Spark task. Detailed information in?\'Mesos Run Modes\'.', 19),
('spark.mesos.constraints', '(none)', 'Attribute based constraints on mesos resource offers. By default, all resource offers will be accepted. This setting applies only to executors. Refer to?Mesos Attributes & Resources?for more information on attributes.\nScalar constraints are matched with \"less than equal\" semantics i.e. value in the constraint must be less than or equal to the value in the resource offer.\nRange constraints are matched with \"contains\" semantics i.e. value in the constraint must be within the resource offer\'s value.\nSet constraints are matched with \"subset of\" semantics i.e. value in the constraint must be a subset of the resource offer\'s value.\nText constraints are matched with \"equality\" semantics i.e. value in the constraint must be exactly equal to the resource offer\'s value.\nIn case there is no value present as a part of the constraint any offer with the corresponding attribute will be accepted (without value check).', 19),
('spark.mesos.containerizer', 'docker', 'This only affects docker containers, and must be one of \"docker\" or \"mesos\". Mesos supports two types of containerizers for docker: the \"docker\" containerizer, and the preferred \"mesos\" containerizer. Read more here: http://mesos.apache.org/documentation/latest/container-image/', 19),
('spark.mesos.dispatcher.driverDefault.[PropertyName]', '(none)', 'Set default properties for drivers submitted through the dispatcher. For example, spark.mesos.dispatcher.driverProperty.spark.executor.memory=32g results in the executors for all drivers submitted in cluster mode to run in 32g containers.', 19),
('spark.mesos.dispatcher.historyServer.url', '(none)', 'Set the URL of the?history server. The dispatcher will then link each driver to its entry in the history server.', 19),
('spark.mesos.dispatcher.webui.url', '(none)', 'Set the Spark Mesos dispatcher webui_url for interacting with the framework. If unset it will point to Spark\'s internal web UI.', 19),
('spark.mesos.driver.constraints', '(none)', 'Same as?spark.mesos.constraints?except applied to drivers when launched through the dispatcher. By default, all offers with sufficient resources will be accepted.', 19),
('spark.mesos.driver.failoverTimeout', '0.0', 'The amount of time (in seconds) that the master will wait for the driver to reconnect, after being temporarily disconnected, before it tears down the driver framework by killing all its executors. The default value is zero, meaning no timeout: if the driver disconnects, the master immediately tears down the framework.', 19),
('spark.mesos.driver.labels', '(none)', 'Mesos labels to add to the driver. See?spark.mesos.task.labelsfor formatting information.', 19),
('spark.mesos.driver.secret.envkeys,spark.mesos.driver.secret.filenames,spark.mesos.executor.secret.en', '(none)', 'A secret is specified by its contents and destination. These properties specify a secret\'s destination. To specify a secret\'s contents, see the cell above.\nYou can specify a secret\'s destination in the driver or executors as either (1) an environment variable or (2) as a file.\n(1) To make an environment-based secret, set the?spark.mesos.[driver|executor].secret.envkeys?property. The secret will appear as an environment variable with the given name in the driver or executors. For example, to make a secret password available to the driver process as $PASSWORD, set:\nspark.mesos.driver.secret.envkeys=PASSWORD\n\n(2) To make a file-based secret, set the?spark.mesos.[driver|executor].secret.filenames?property. The secret will appear in the contents of a file with the given file name in the driver or executors. For example, to make a secret password available in a file named \"pwdfile\" in the driver process, set:\nspark.mesos.driver.secret.filenames=pwdfile\n\nPaths are relative to the container\'s work directory. Absolute paths must already exist. Note: File-based secrets require a customSecretResolver module.\nTo specify env vars or file names corresponding to multiple secrets, provide a comma-separated list:\nspark.mesos.driver.secret.envkeys=PASSWORD1,PASSWORD2\nor\nspark.mesos.driver.secret.filenames=pwdfile1,pwdfile2', 19);
INSERT INTO `conf` (`conf_name`, `default_value`, `conf_desc`, `conf_type`) VALUES
('spark.mesos.driver.secret.values,spark.mesos.driver.secret.names,spark.mesos.executor.secret.values,', '(none)', 'A secret is specified by its contents and destination. These properties specify a secret\'s contents. To specify a secret\'s destination, see the cell below.\nYou can specify a secret\'s contents either (1) by value or (2) by reference.\n(1) To specify a secret by value, set the?spark.mesos.[driver|executor].secret.values?property, to make the secret available in the driver or executors. For example, to make a secret password \"guessme\" available to the driver process, set:\nspark.mesos.driver.secret.values=guessme\n\n(2) To specify a secret that has been placed in a secret store by reference, specify its name within the secret store by setting the?spark.mesos.[driver|executor].secret.names?property. For example, to make a secret password named \"password\" in a secret store available to the driver process, set:\nspark.mesos.driver.secret.names=password\n\nNote: To use a secret store, make sure one has been integrated with Mesos via a custom?SecretResolver module.\nTo specify multiple secrets, provide a comma-separated list:\nspark.mesos.driver.secret.values=guessme,passwd123\nor\nspark.mesos.driver.secret.names=password1,password2', 19),
('spark.mesos.driver.webui.url', '(none)', 'Set the Spark Mesos driver webui_url for interacting with the framework. If unset it will point to Spark\'s internal web UI.', 19),
('spark.mesos.driverEnv.[EnvironmentVariableName]', '(none)', 'This only affects drivers submitted in cluster mode. Add the environment variable specified by EnvironmentVariableName to the driver process. The user can specify multiple of these to set multiple environment variables.', 19),
('spark.mesos.executor.docker.forcePullImage', 'FALSE', 'Force Mesos agents to pull the image specified in?spark.mesos.executor.docker.image. By default Mesos agents will not pull images they already have cached.', 19),
('spark.mesos.executor.docker.image', '(none)', 'Set the name of the docker image that the Spark executors will run in. The selected image must have Spark installed, as well as a compatible version of the Mesos library. The installed path of Spark in the image can be specified with?spark.mesos.executor.home; the installed path of the Mesos library can be specified with?spark.executorEnv.MESOS_NATIVE_JAVA_LIBRARY.', 19),
('spark.mesos.executor.docker.parameters', '(none)', 'Set the list of custom parameters which will be passed into the?docker run?command when launching the Spark executor on Mesos using the docker containerizer. The format of this property is a comma-separated list of key/value pairs. Example:\nkey1=val1,key2=val2,key3=val3', 19),
('spark.mesos.executor.docker.volumes', '(none)', 'Set the list of volumes which will be mounted into the Docker image, which was set using?spark.mesos.executor.docker.image. The format of this property is a comma-separated list of mappings following the form passed to?docker run -v. That is they take the form:\n[host_path:]container_path[:ro|:rw]', 19),
('spark.mesos.executor.home', 'driver side?SPARK_HOME', 'Set the directory in which Spark is installed on the executors in Mesos. By default, the executors will simply use the driver\'s Spark home directory, which may not be visible to them. Note that this is only relevant if a Spark binary package is not specified throughspark.executor.uri.', 19),
('spark.mesos.executor.memoryOverhead', 'executor memory * 0.10, with minimum of 384', 'The amount of additional memory, specified in MB, to be allocated per executor. By default, the overhead will be larger of either 384 or 10% of?spark.executor.memory. If set, the final overhead will be this value.', 19),
('spark.mesos.extra.cores', '0', 'Set the extra number of cores for an executor to advertise. This does not result in more cores allocated. It instead means that an executor will \"pretend\" it has more cores, so that the driver will send it more tasks. Use this to increase parallelism. This setting is only used for Mesos coarse-grained mode.', 19),
('spark.mesos.fetcherCache.enable', 'FALSE', 'If set to `true`, all URIs (example: `spark.executor.uri`, `spark.mesos.uris`) will be cached by the?Mesos Fetcher Cache', 19),
('spark.mesos.gpus.max', '0', 'Set the maximum number GPU resources to acquire for this job. Note that executors will still launch when no GPU resources are found since this configuration is just a upper limit and not a guaranteed amount.', 19),
('spark.mesos.mesosExecutor.cores', '1.0', '(Fine-grained mode only) Number of cores to give each Mesos executor. This does not include the cores used to run the Spark tasks. In other words, even if no Spark task is being run, each Mesos executor will occupy the number of cores configured here. The value can be a floating point number.', 19),
('spark.mesos.network.labels', '(none)', 'Pass network labels to CNI plugins. This is a comma-separated list of key-value pairs, where each key-value pair has the format key:value. Example:\nkey1:val1,key2:val2\nSee?the Mesos CNI docs?for more details.', 19),
('spark.mesos.network.name', '(none)', 'Attach containers to the given named network. If this job is launched in cluster mode, also launch the driver in the given named network. See?the Mesos CNI docs?for more details.', 19),
('spark.mesos.principal', '(none)', 'Set the principal with which Spark framework will use to authenticate with Mesos.', 19),
('spark.mesos.rejectOfferDuration', '120s', 'Time to consider unused resources refused, serves as a fallback of `spark.mesos.rejectOfferDurationForUnmetConstraints`, `spark.mesos.rejectOfferDurationForReachedMaxCores`', 19),
('spark.mesos.rejectOfferDurationForReachedMaxCores', 'spark.mesos.rejectOfferDuration', 'Time to consider unused resources refused when maximum number of cores?spark.cores.max?is reached', 19),
('spark.mesos.rejectOfferDurationForUnmetConstraints', 'spark.mesos.rejectOfferDuration', 'Time to consider unused resources refused with unmet constraints', 19),
('spark.mesos.role', '*', 'Set the role of this Spark framework for Mesos. Roles are used in Mesos for reservations and resource weight sharing.', 19),
('spark.mesos.secret', '(none)', 'Set the secret with which Spark framework will use to authenticate with Mesos. Used, for example, when authenticating with the registry.', 19),
('spark.mesos.task.labels', '(none)', 'Set the Mesos labels to add to each task. Labels are free-form key-value pairs. Key-value pairs should be separated by a colon, and commas used to list more than one. If your label includes a colon or comma, you can escape it with a backslash. Ex. key:value,key2:a\\:b.', 19),
('spark.mesos.uris', '(none)', 'A comma-separated list of URIs to be downloaded to the sandbox when driver or executor is launched by Mesos. This applies to both coarse-grained and fine-grained mode.', 19),
('spark.modify.acls', 'Empty', 'Comma separated list of users that have modify access to the Spark job. By default only the user that started the Spark job has access to modify it (kill it for example). Putting a \"*\" in the list means any user can have access to modify it.', 11),
('spark.modify.acls.groups', 'Empty', 'Comma separated list of groups that have modify access to the Spark job. This can be used if you have a set of administrators or developers from the same team to have access to control the job. Putting a \"*\" in the list means any user in any group has the access to modify the Spark job. The user groups are obtained from the instance of the groups mapping provider specified byspark.user.groups.mapping. Check the entry?spark.user.groups.mapping?for more details.', 11),
('spark.network.crypto.config.*', 'None', 'Configuration values for the commons-crypto library, such as which cipher implementations to use. The config name should be the name of commons-crypto configuration without the \"commons.crypto\" prefix.', 11),
('spark.network.crypto.enabled', 'FALSE', 'Enable encryption using the commons-crypto library for RPC and block transfer service. Requires?spark.authenticate?to be enabled.', 11),
('spark.network.crypto.keyFactoryAlgorithm', 'PBKDF2WithHmacSHA1', 'The key factory algorithm to use when generating encryption keys. Should be one of the algorithms supported by the javax.crypto.SecretKeyFactory class in the JRE being used.', 11),
('spark.network.crypto.keyLength', '128', 'The length in bits of the encryption key to generate. Valid values are 128, 192 and 256.', 11),
('spark.network.crypto.saslFallback', 'TRUE', 'Whether to fall back to SASL authentication if authentication fails using Spark\'s internal mechanism. This is useful when the application is connecting to old shuffle services that do not support the internal Spark authentication protocol. On the server side, this can be used to block older clients from authenticating against a new shuffle service.', 11),
('spark.network.sasl.serverAlwaysEncrypt', 'FALSE', 'Disable unencrypted connections for services that support SASL authentication.', 11),
('spark.network.timeout', '120s', 'Default timeout for all network interactions. This config will be used in place ofspark.core.connection.ack.wait.timeout,spark.storage.blockManagerSlaveTimeoutMs,spark.shuffle.io.connectionTimeout,?spark.rpc.askTimeout?orspark.rpc.lookupTimeout?if they are not configured.', 8),
('spark.port.maxRetries', '16', 'Maximum number of retries when binding to a port before giving up. When a port is given a specific value (non 0), each subsequent retry will increment the port used in the previous attempt by 1 before retrying. This essentially allows it to try a range of ports from the start port specified to port + maxRetries.', 8),
('spark.pyspark.driver.python', '', 'Python binary executable to use for PySpark in driver. (default is?spark.pyspark.python)', 2),
('spark.pyspark.python', '', 'Python binary executable to use for PySpark in both driver and executors.', 2),
('spark.python.profile', 'FALSE', 'Enable profiling in Python worker, the profile result will show up by?sc.show_profiles(), or it will be displayed before the driver exits. It also can be dumped into disk by?sc.dump_profiles(path). If some of the profile results had been displayed manually, they will not be displayed automatically before driver exiting. By default the?pyspark.profiler.BasicProfiler?will be used, but this can be overridden by passing a profiler class in as a parameter to the?SparkContext?constructor.', 2),
('spark.python.profile.dump', '(none)', 'The directory which is used to dump the profile result before driver exiting. The results will be dumped as separated file for each RDD. They can be loaded by ptats.Stats(). If this is specified, the profile result will not be displayed automatically.', 2),
('spark.python.worker.memory', '512m', 'Amount of memory to use per python worker process during aggregation, in the same format as JVM memory strings with a size unit suffix (\"k\", \"m\", \"g\" or \"t\") (e.g.?512m,?2g). If the memory used during aggregation goes above this amount, it will spill the data into disks.', 2),
('spark.python.worker.reuse', 'TRUE', 'Reuse Python worker or not. If yes, it will use a fixed number of Python workers, does not need to fork() a Python process for every task. It will be very useful if there is large broadcast, then the broadcast will not be needed to transferred from JVM to Python worker for every task.', 2),
('spark.r.backendConnectionTimeout', '6000', 'Connection timeout set by R process on its connection to RBackend in seconds.', 15),
('spark.r.command', 'Rscript', 'Executable for executing R scripts in cluster modes for both driver and workers.', 15),
('spark.r.driver.command', 'spark.r.command', 'Executable for executing R scripts in client modes for driver. Ignored in cluster modes.', 15),
('spark.r.heartBeatInterval', '100', 'Interval for heartbeats sent from SparkR backend to R process to prevent connection timeout.', 15),
('spark.r.numRBackendThreads', '2', 'Number of threads used by RBackend to handle RPC calls from SparkR package.', 15),
('spark.r.shell.command', 'R', 'Executable for executing sparkR shell in client modes for driver. Ignored in cluster modes. It is the same as environment variable?SPARKR_DRIVER_R, but take precedence over it.?spark.r.shell.command?is used for sparkR shell while?spark.r.driver.command?is used for running R script.', 15),
('spark.rdd.compress', 'FALSE', 'Whether to compress serialized RDD partitions (e.g. forStorageLevel.MEMORY_ONLY_SER?in Java and Scala or?StorageLevel.MEMORY_ONLY?in Python). Can save substantial space at the cost of some extra CPU time. Compression will use?spark.io.compression.codec.', 5),
('spark.redaction.regex', '(?i)secret|password', 'Regex to decide which Spark configuration properties and environment variables in driver and executor environments contain sensitive information. When this regex matches a property key or value, the value is redacted from the environment UI and various logs like YARN and event logs.', 2),
('spark.reducer.maxBlocksInFlightPerAddress', 'Int.MaxValue', 'This configuration limits the number of remote blocks being fetched per reduce task from a given host port. When a large number of blocks are being requested from a given address in a single fetch or simultaneously, this could crash the serving executor or Node Manager. This is especially useful to reduce the load on the Node Manager when external shuffle is enabled. You can mitigate this issue by setting it to a lower value.', 3),
('spark.reducer.maxReqsInFlight', 'Int.MaxValue', 'This configuration limits the number of remote requests to fetch blocks at any given point. When the number of hosts in the cluster increase, it might lead to very large number of in-bound connections to one or more nodes, causing the workers to fail under load. By allowing it to limit the number of fetch requests, this scenario can be mitigated.', 3),
('spark.reducer.maxSizeInFlight', '48m', 'Maximum size of map outputs to fetch simultaneously from each reduce task, in MiB unless otherwise specified. Since each output requires us to create a buffer to receive it, this represents a fixed memory overhead per reduce task, so keep it small unless you have a large amount of memory.', 3),
('spark.rpc.askTimeout', 'spark.network.timeout', 'Duration for an RPC ask operation to wait before timing out.', 8),
('spark.rpc.lookupTimeout', '120s', 'Duration for an RPC remote endpoint lookup operation to wait before timing out.', 8),
('spark.rpc.message.maxSize', '128', 'Maximum message size (in MB) to allow in \"control plane\" communication; generally only applies to map output size information sent between executors and the driver. Increase this if you are running jobs with many thousands of map and reduce tasks and see messages about the RPC message size.', 8),
('spark.rpc.numRetries', '3', 'Number of times to retry before an RPC task gives up. An RPC task will run at most times of this number.', 8),
('spark.rpc.retry.wait', '3s', 'Duration for an RPC ask operation to wait before retrying.', 8),
('spark.scheduler.listenerbus.eventqueue.capacity', '10000', 'Capacity for event queue in Spark listener bus, must be greater than 0. Consider increasing value (e.g. 20000) if listener events are dropped. Increasing this value may result in the driver using more memory.', 9),
('spark.scheduler.maxRegisteredResourcesWaitingTime', '30s', 'Maximum amount of time to wait for resources to register before scheduling begins.', 9),
('spark.scheduler.minRegisteredResourcesRatio', '0.8 for KUBERNETES mode; 0.8 for YARN mode; 0.0 for standalone mode and Mesos coarse-grained mode', 'The minimum ratio of registered resources (registered resources / total expected resources) (resources are executors in yarn mode and Kubernetes mode, CPU cores in standalone mode and Mesos coarsed-grained mode [\'spark.cores.max\' value is total expected resources for Mesos coarse-grained mode] ) to wait for before scheduling begins. Specified as a double between 0.0 and 1.0. Regardless of whether the minimum ratio of resources has been reached, the maximum amount of time it will wait before scheduling begins is controlled by configspark.scheduler.maxRegisteredResourcesWaitingTime.', 9),
('spark.scheduler.mode', 'FIFO', 'The?scheduling mode?between jobs submitted to the same SparkContext. Can be set to?FAIR?to use fair sharing instead of queueing jobs one after another. Useful for multi-user services.', 9),
('spark.scheduler.revive.interval', '1s', 'The interval length for the scheduler to revive the worker resource offers to run tasks.', 9),
('spark.security.credentials.${service}.enabled', 'TRUE', 'Controls whether to obtain credentials for services when security is enabled. By default, credentials for all supported services are retrieved when those services are configured, but it\'s possible to disable that behavior if it somehow conflicts with the application being run. For further details please see [Running in a Secure Cluster](running-on-yarn.html#running-in-a-secure-cluster)', 18),
('spark.serializer', 'org.apache.spark.serializer.\nJavaSerializer', 'Class to use for serializing objects that will be sent over the network or need to be cached in serialized form. The default of Java serialization works with any Serializable Java object but is quite slow, so we recommend?usingorg.apache.spark.serializer.KryoSerializer?and configuring Kryo serialization?when speed is necessary. Can be any subclass oforg.apache.spark.Serializer.', 5),
('spark.serializer.objectStreamReset', '100', 'When serializing using org.apache.spark.serializer.JavaSerializer, the serializer caches objects to prevent writing redundant data, however that stops garbage collection of those objects. By calling \'reset\' you flush that info from the serializer, and allow old objects to be collected. To turn off this periodic reset set it to -1. By default it will reset the serializer every 100 objects.', 5),
('spark.shuffle.accurateBlockThreshold', '100 * 1024 * 1024', 'Threshold in bytes above which the size of shuffle blocks in HighlyCompressedMapStatus is accurately recorded. This helps to prevent OOM by avoiding underestimating shuffle block size when fetch shuffle blocks.', 3),
('spark.shuffle.compress', 'TRUE', 'Whether to compress map output files. Generally a good idea. Compression will use?spark.io.compression.codec.', 3),
('spark.shuffle.file.buffer', '32k', 'Size of the in-memory buffer for each shuffle file output stream, in KiB unless otherwise specified. These buffers reduce the number of disk seeks and system calls made in creating intermediate shuffle files.', 3),
('spark.shuffle.io.maxRetries', '3', '(Netty only) Fetches that fail due to IO-related exceptions are automatically retried if this is set to a non-zero value. This retry logic helps stabilize large shuffles in the face of long GC pauses or transient network connectivity issues.', 3),
('spark.shuffle.io.numConnectionsPerPeer', '1', '(Netty only) Connections between hosts are reused in order to reduce connection buildup for large clusters. For clusters with many hard disks and few hosts, this may result in insufficient concurrency to saturate all disks, and so users may consider increasing this value.', 3),
('spark.shuffle.io.preferDirectBufs', 'TRUE', '(Netty only) Off-heap buffers are used to reduce garbage collection during shuffle and cache block transfer. For environments where off-heap memory is tightly limited, users may wish to turn this off to force all allocations from Netty to be on-heap.', 3),
('spark.shuffle.io.retryWait', '5s', '(Netty only) How long to wait between retries of fetches. The maximum delay caused by retrying is 15 seconds by default, calculated as?maxRetries * retryWait.', 3),
('spark.shuffle.maxChunksBeingTransferred', 'Long.MAX_VALUE', 'The max number of chunks allowed to be transferred at the same time on shuffle service. Note that new incoming connections will be closed when the max number is hit. The client will retry according to the shuffle retry configs (see?spark.shuffle.io.maxRetries?andspark.shuffle.io.retryWait), if those limits are reached the task will fail with fetch failure.', 3),
('spark.shuffle.memoryFraction', '0.2', '(deprecated) This is read only if?spark.memory.useLegacyMode?is enabled. Fraction of Java heap to use for aggregation and cogroups during shuffles. At any given time, the collective size of all in-memory maps used for shuffles is bounded by this limit, beyond which the contents will begin to spill to disk. If spills are often, consider increasing this value at the expense of?spark.storage.memoryFraction.', 6),
('spark.shuffle.registration.maxAttempts', '3', 'When we fail to register to the external shuffle service, we will retry for maxAttempts times.', 3),
('spark.shuffle.registration.timeout', '5000', 'Timeout in milliseconds for registration to the external shuffle service.', 3),
('spark.shuffle.service.enabled', 'FALSE', 'Enables the external shuffle service. This service preserves the shuffle files written by executors so the executors can be safely removed. This must be enabled if?spark.dynamicAllocation.enabled?is \"true\". The external shuffle service must be set up in order to enable it. Seedynamic allocation configuration and setup documentation?for more information.', 3),
('spark.shuffle.service.index.cache.size', '100m', 'Cache entries limited to the specified memory footprint in bytes.', 3),
('spark.shuffle.service.port', '7337', 'Port on which the external shuffle service will run.', 3),
('spark.shuffle.sort.bypassMergeThreshold', '200', '(Advanced) In the sort-based shuffle manager, avoid merge-sorting data if there is no map-side aggregation and there are at most this many reduce partitions.', 3),
('spark.shuffle.spill.compress', 'TRUE', 'Whether to compress data spilled during shuffles. Compression will usespark.io.compression.codec.', 3),
('spark.speculation', 'FALSE', 'If set to \"true\", performs speculative execution of tasks. This means if one or more tasks are running slowly in a stage, they will be re-launched.', 9),
('spark.speculation.interval', '100ms', 'How often Spark will check for tasks to speculate.', 9),
('spark.speculation.multiplier', '1.5', 'How many times slower a task is than the median to be considered for speculation.', 9),
('spark.speculation.quantile', '0.75', 'Fraction of tasks which must be complete before speculation is enabled for a particular stage.', 9),
('spark.sql.adaptive.enabled', 'false', 'When true, enable adaptive query execution.', 13),
('spark.sql.adaptive.shuffle.targetPostShuffleInputSize', '67108864b', 'The target post-shuffle input size in bytes of a task.', 13),
('spark.sql.autoBroadcastJoinThreshold', '10485760', 'Configures the maximum size in bytes for a table that will be broadcast to all worker nodes when performing a join.  By setting this value to -1 broadcasting can be disabled. Note that currently statistics are only supported for Hive Metastore tables where the command <code>ANALYZE TABLE &lt;tableName&gt; COMPUTE STATISTICS noscan</code> has been run, and file-based data source tables where the statistics are computed directly on the files of data.', 13),
('spark.sql.broadcastTimeout', '300000ms', 'Timeout in seconds for the broadcast wait time in broadcast joins.', 13),
('spark.sql.cbo.enabled', 'false', 'Enables CBO for estimation of plan statistics when set true.', 13),
('spark.sql.cbo.joinReorder.dp.star.filter', 'false', 'Applies star-join filter heuristics to cost based join enumeration.', 13),
('spark.sql.cbo.joinReorder.dp.threshold', '12', 'The maximum number of joined nodes allowed in the dynamic programming algorithm.', 13),
('spark.sql.cbo.joinReorder.enabled', 'false', 'Enables join reorder in CBO.', 13),
('spark.sql.cbo.starSchemaDetection', 'false', 'When true, it enables join reordering based on star schema detection.', 13),
('spark.sql.columnNameOfCorruptRecord', '_corrupt_record', 'The name of internal column for storing raw/un-parsed JSON and CSV records that fail to parse.', 13),
('spark.sql.crossJoin.enabled', 'false', 'When false, we will throw an error if a query contains a cartesian product without explicit CROSS JOIN syntax.', 13),
('spark.sql.execution.arrow.enabled', 'false', 'When true, make use of Apache Arrow for columnar data transfers. Currently available for use with pyspark.sql.DataFrame.toPandas, and pyspark.sql.SparkSession.createDataFrame when its input is a Pandas DataFrame. The following data types are unsupported: BinaryType, MapType, ArrayType of TimestampType, and nested StructType.', 13),
('spark.sql.execution.arrow.maxRecordsPerBatch', '10000', 'When using Apache Arrow, limit the maximum number of records that can be written to a single ArrowRecordBatch in memory. If set to zero or negative there is no limit.', 13),
('spark.sql.extensions', '<undefined>', 'Name of the class used to configure Spark Session extensions. The class should implement Function1[SparkSessionExtension, Unit], and must have a no-args constructor.', 13),
('spark.sql.files.ignoreCorruptFiles', 'false', 'Whether to ignore corrupt files. If true, the Spark jobs will continue to run when encountering corrupted files and the contents that have been read will still be returned.', 13),
('spark.sql.files.ignoreMissingFiles', 'false', 'Whether to ignore missing files. If true, the Spark jobs will continue to run when encountering missing files and the contents that have been read will still be returned.', 13),
('spark.sql.files.maxPartitionBytes', '134217728', 'The maximum number of bytes to pack into a single partition when reading files.', 13),
('spark.sql.files.maxRecordsPerFile', '0', 'Maximum number of records to write out to a single file. If this value is zero or negative, there is no limit.', 13),
('spark.sql.function.concatBinaryAsString', 'false', 'When this option is set to false and all inputs are binary, `functions.concat` returns an output as binary. Otherwise, it returns as a string.', 13),
('spark.sql.function.eltOutputAsString', 'false', 'When this option is set to false and all inputs are binary, `elt` returns an output as binary. Otherwise, it returns as a string.', 13),
('spark.sql.groupByAliases', 'true', 'When true, aliases in a select list can be used in group by clauses. When false, an analysis exception is thrown in the case.', 13),
('spark.sql.groupByOrdinal', 'true', 'When true, the ordinal numbers in group by clauses are treated as the position in the select list. When false, the ordinal numbers are ignored.', 13),
('spark.sql.hive.caseSensitiveInferenceMode', 'INFER_AND_SAVE', 'Sets the action to take when a case-sensitive schema cannot be read from a Hive table\'s properties. Although Spark SQL itself is not case-sensitive, Hive compatible file formats such as Parquet are. Spark SQL must use a case-preserving schema when querying any table backed by files containing case-sensitive field names or queries may not return accurate results. Valid options include INFER_AND_SAVE (the default mode-- infer the case-sensitive schema from the underlying data files and write it back to the table properties), INFER_ONLY (infer the schema but don\'t attempt to write it to the table properties) and NEVER_INFER (fallback to using the case-insensitive metastore schema instead of inferring).', 13),
('spark.sql.hive.convertMetastoreParquet', 'true', 'When set to true, the built-in Parquet reader and writer are used to process parquet tables created by using the HiveQL syntax, instead of Hive serde.', 13),
('spark.sql.hive.convertMetastoreParquet.mergeSchema', 'false', 'When true, also tries to merge possibly different but compatible Parquet schemas in different Parquet data files. This configuration is only effective when \"spark.sql.hive.convertMetastoreParquet\" is true.', 13),
('spark.sql.hive.filesourcePartitionFileCacheSize', '262144000', 'When nonzero, enable caching of partition file metadata in memory. All tables share a cache that can use up to specified num bytes for file metadata. This conf only has an effect when hive filesource partition management is enabled.', 13),
('spark.sql.hive.manageFilesourcePartitions', 'true', 'When true, enable metastore partition management for file source tables as well. This includes both datasource and converted Hive tables. When partition management is enabled, datasource tables store partition in the Hive metastore, and use the metastore to prune partitions during query planning.', 13),
('spark.sql.hive.metastore.barrierPrefixes', '', 'A comma separated list of class prefixes that should explicitly be reloaded for each version of Hive that Spark SQL is communicating with. For example, Hive UDFs that are declared in a prefix that typically would be shared (i.e. <code>org.apache.spark.*</code>).', 13),
('spark.sql.hive.metastore.jars', 'builtin', ' Location of the jars that should be used to instantiate the HiveMetastoreClient.  This property can be one of three options: ? 1. ?builtin? Use Hive 1.2.1,  which is bundled with the Spark assembly when    <code>-Phive</code> is enabled. When this option is chosen    <code>spark.sql.hive.metastore.version</code> must be either <code>1.2.1</code> or not defined. 2. ?maven?    Use Hive jars of specified version downloaded from Maven repositories. 3. A classpath in the standard format for both Hive and Hadoop.', 13),
('spark.sql.hive.metastore.sharedPrefixes', 'com.mysql.jdbc,org.postgresql,com.microsoft.sqlserver,oracle.jdbc', 'A comma separated list of class prefixes that should be loaded using the classloader that is shared between Spark SQL and a specific version of Hive. An example of classes that should be shared is JDBC drivers that are needed to talk to the metastore. Other classes that need to be shared are those that interact with classes that are already shared. For example, custom appenders that are used by log4j.', 13),
('spark.sql.hive.metastore.version', '1.2.1', 'Version of the Hive metastore. Available options are <code>0.12.0</code> through <code>2.1.1</code>.', 13),
('spark.sql.hive.metastorePartitionPruning', 'true', 'When true, some predicates will be pushed down into the Hive metastore so that unmatching partitions can be eliminated earlier. This only affects Hive tables not converted to filesource relations (see HiveUtils.CONVERT_METASTORE_PARQUET and HiveUtils.CONVERT_METASTORE_ORC for more information).', 13),
('spark.sql.hive.thriftServer.async', 'true', 'When set to true, Hive Thrift server executes SQL queries in an asynchronous way.', 13),
('spark.sql.hive.thriftServer.singleSession', 'false', 'When set to true, Hive Thrift server is running in a single session mode. All the JDBC/ODBC connections share the temporary views, function registries, SQL configuration and the current database.', 13),
('spark.sql.hive.verifyPartitionPath', 'false', 'When true, check all the partition paths under the table\'s root directory when reading data stored in HDFS.', 13),
('spark.sql.hive.version', '1.2.1', 'deprecated, please use spark.sql.hive.metastore.version to get the Hive version in Spark.', 13),
('spark.sql.inMemoryColumnarStorage.batchSize', '10000', 'Controls the size of batches for columnar caching.  Larger batch sizes can improve memory utilization and compression, but risk OOMs when caching data.', 13),
('spark.sql.inMemoryColumnarStorage.compressed', 'true', 'When set to true Spark SQL will automatically select a compression codec for each column based on statistics of the data.', 13),
('spark.sql.inMemoryColumnarStorage.enableVectorizedReader', 'true', 'Enables vectorized reader for columnar caching.', 13),
('spark.sql.optimizer.metadataOnly', 'true', 'When true, enable the metadata-only query optimization that use the table\'s metadata to produce the partition columns instead of table scans. It applies when all the columns scanned are partition columns and the query has an aggregate operator that satisfies distinct semantics.', 13),
('spark.sql.orc.compression.codec', 'snappy', 'Sets the compression codec used when writing ORC files. If either `compression` or `orc.compress` is specified in the table-specific options/properties, the precedence would be `compression`, `orc.compress`, `spark.sql.orc.compression.codec`.Acceptable values include: none, uncompressed, snappy, zlib, lzo.', 13),
('spark.sql.orc.enableVectorizedReader', 'true', 'Enables vectorized orc decoding.', 13),
('spark.sql.orc.filterPushdown', 'false', 'When true, enable filter pushdown for ORC files.', 13),
('spark.sql.orderByOrdinal', 'true', 'When true, the ordinal numbers are treated as the position in the select list. When false, the ordinal numbers in order/sort by clause are ignored.', 13),
('spark.sql.parquet.binaryAsString', 'false', 'Some other Parquet-producing systems, in particular Impala and older versions of Spark SQL, do not differentiate between binary data and strings when writing out the Parquet schema. This flag tells Spark SQL to interpret binary data as a string to provide compatibility with these systems.', 13),
('spark.sql.parquet.cacheMetadata', 'true', 'Turns on caching of Parquet schema metadata. Can speed up querying of static data.', 13),
('spark.sql.parquet.compression.codec', 'snappy', 'Sets the compression codec used when writing Parquet files. If either `compression` or `parquet.compression` is specified in the table-specific options/properties, the precedence would be `compression`, `parquet.compression`, `spark.sql.parquet.compression.codec`. Acceptable values include: none, uncompressed, snappy, gzip, lzo.', 13),
('spark.sql.parquet.enableVectorizedReader', 'true', 'Enables vectorized parquet decoding.', 13),
('spark.sql.parquet.filterPushdown', 'true', 'Enables Parquet filter push-down optimization when set to true.', 13),
('spark.sql.parquet.int64AsTimestampMillis', 'false', '(Deprecated since Spark 2.3, please set spark.sql.parquet.outputTimestampType.) When true, timestamp values will be stored as INT64 with TIMESTAMP_MILLIS as the extended type. In this mode, the microsecond portion of the timestamp value will betruncated.', 13),
('spark.sql.parquet.int96AsTimestamp', 'true', 'Some Parquet-producing systems, in particular Impala, store Timestamp into INT96. Spark would also store Timestamp as INT96 because we need to avoid precision lost of the nanoseconds field. This flag tells Spark SQL to interpret INT96 data as a timestamp to provide compatibility with these systems.', 13),
('spark.sql.parquet.int96TimestampConversion', 'false', 'This controls whether timestamp adjustments should be applied to INT96 data when converting to timestamps, for data written by Impala.  This is necessary because Impala stores INT96 data with a different timezone offset than Hive & Spark.', 13),
('spark.sql.parquet.mergeSchema', 'false', 'When true, the Parquet data source merges schemas collected from all data files, otherwise the schema is picked from the summary file or a random data file if no summary file is available.', 13),
('spark.sql.parquet.outputTimestampType', 'INT96', 'Sets which Parquet timestamp type to use when Spark writes data to Parquet files. INT96 is a non-standard but commonly used timestamp type in Parquet. TIMESTAMP_MICROS is a standard timestamp type in Parquet, which stores number of microseconds from the Unix epoch. TIMESTAMP_MILLIS is also standard, but with millisecond precision, which means Spark has to truncate the microsecond portion of its timestamp value.', 13),
('spark.sql.parquet.recordLevelFilter.enabled', 'false', 'If true, enables Parquet\'s native record-level filtering using the pushed down filters. This configuration only has an effect when \'spark.sql.parquet.filterPushdown\' is enabled.', 13),
('spark.sql.parquet.respectSummaryFiles', 'false', 'When true, we make assumption that all part-files of Parquet are consistent with summary files and we will ignore them when merging schema. Otherwise, if this is false, which is the default, we will merge all part-files. This should be considered as expert-only option, and shouldn\'t be enabled before knowing what it means exactly.', 13),
('spark.sql.parquet.writeLegacyFormat', 'false', 'Whether to be compatible with the legacy Parquet format adopted by Spark 1.4 and prior versions, when converting Parquet schema to Spark SQL schema and vice versa.', 13),
('spark.sql.parser.quotedRegexColumnNames', 'false', 'When true, quoted Identifiers (using backticks) in SELECT statement are interpreted as regular expressions.', 13),
('spark.sql.pivotMaxValues', '10000', 'When doing a pivot without specifying values for the pivot column this is the maximum number of (distinct) values that will be collected without error.', 13),
('spark.sql.queryExecutionListeners', '<undefined>', 'List of class names implementing QueryExecutionListener that will be automatically added to newly created sessions. The classes should have either a no-arg constructor, or a constructor that expects a SparkConf argument.', 13),
('spark.sql.session.timeZone', 'Asia/Shanghai', 'The ID of session local timezone, e.g. \"GMT\", \"America/Los_Angeles\", etc.', 13),
('spark.sql.shuffle.partitions', '200', 'The default number of partitions to use when shuffling data for joins or aggregations.', 13),
('spark.sql.sources.bucketing.enabled', 'true', 'When false, we will treat bucketed table as normal table', 13),
('spark.sql.sources.default', 'parquet', 'The default data source to use in input/output.', 13),
('spark.sql.sources.parallelPartitionDiscovery.threshold', '32', 'The maximum number of paths allowed for listing files at driver side. If the number of detected paths exceeds this value during partition discovery, it tries to list the files with another Spark distributed job. This applies to Parquet, ORC, CSV, JSON and LibSVM data sources.', 13),
('spark.sql.sources.partitionColumnTypeInference.enabled', 'true', 'When true, automatically infer the data types for partitioned columns.', 13),
('spark.sql.sources.partitionOverwriteMode', 'STATIC', 'When INSERT OVERWRITE a partitioned data source table, we currently support 2 modes: static and dynamic. In static mode, Spark deletes all the partitions that match the partition specification(e.g. PARTITION(a=1,b)) in the INSERT statement, before overwriting. In dynamic mode, Spark doesn\'t delete partitions ahead, and only overwrite those partitions that have data written into it at runtime. By default we use static mode to keep the same behavior of Spark prior to 2.3. Note that this config doesn\'t affect Hive serde tables, as they are always overwritten with dynamic mode.', 13),
('spark.sql.statistics.fallBackToHdfs', 'false', 'If the table statistics are not available from table metadata enable fall back to hdfs. This is useful in determining if a table is small enough to use auto broadcast joins.', 13),
('spark.sql.statistics.histogram.enabled', 'false', 'Generates histograms when computing column statistics if enabled. Histograms can provide better estimation accuracy. Currently, Spark only supports equi-height histogram. Note that collecting histograms takes extra cost. For example, collecting column statistics usually takes only one table scan, but generating equi-height histogram will cause an extra table scan.', 13),
('spark.sql.statistics.size.autoUpdate.enabled', 'false', 'Enables automatic update for table size once table\'s data is changed. Note that if the total number of files of the table is very large, this can be expensive and slow down data change commands.', 13),
('spark.sql.streaming.checkpointLocation', '<undefined>', 'The default location for storing checkpoint data for streaming queries.', 13),
('spark.sql.streaming.metricsEnabled', 'false', 'Whether Dropwizard/Codahale metrics will be reported for active streaming queries.', 13),
('spark.sql.streaming.numRecentProgressUpdates', '100', 'The number of progress updates to retain for a streaming query', 13),
('spark.sql.thriftserver.scheduler.pool', '<undefined>', 'Set a Fair Scheduler pool for a JDBC client session.', 13),
('spark.sql.thriftserver.ui.retainedSessions', '200', 'The number of SQL client sessions kept in the JDBC/ODBC web UI history.', 13),
('spark.sql.thriftserver.ui.retainedStatements', '200', 'The number of SQL statements kept in the JDBC/ODBC web UI history.', 13),
('spark.sql.ui.retainedExecutions', '1000', 'Number of executions to retain in the Spark UI.', 13),
('spark.sql.variable.substitute', 'true', 'This enables substitution using syntax like ${var} ${system:var} and ${env:var}.', 13),
('spark.sql.warehouse.dir', './spark-warehouse', 'The default location for managed databases and tables', 13),
('spark.ssl.[namespace].port', 'None', 'The port where the SSL service will listen on.?\nThe port must be defined within a namespace configuration; see?SSL Configuration?for the available namespaces.?\nWhen not set, the SSL port will be derived from the non-SSL port for the same service. A value of \"0\" will make the service bind to an ephemeral port.', 12),
('spark.ssl.enabled', 'FALSE', 'Whether to enable SSL connections on all supported protocols.?\nWhen?spark.ssl.enabled?is configured,?spark.ssl.protocol?is required.?\nAll the SSL settings like?spark.ssl.xxx?where?xxx?is a particular configuration property, denote the global configuration for all the supported protocols. In order to override the global configuration for the particular protocol, the properties must be overwritten in the protocol-specific namespace.?\nUse?spark.ssl.YYY.XXX?settings to overwrite the global configuration for particular protocol denoted by?YYY. Example values for?YYY?include?fs,?ui,?standalone, and?historyServer. See?SSL Configuration?for details on hierarchical SSL configuration for services.', 12),
('spark.ssl.enabledAlgorithms', 'Empty', 'A comma separated list of ciphers. The specified ciphers must be supported by JVM. The reference list of protocols one can find on?this?page. Note: If not set, it will use the default cipher suites of JVM.', 12),
('spark.ssl.keyPassword', 'None', 'A password to the private key in key-store.', 12),
('spark.ssl.keyStore', 'None', 'A path to a key-store file. The path can be absolute or relative to the directory where the component is started in.', 12),
('spark.ssl.keyStorePassword', 'None', 'A password to the key-store.', 12),
('spark.ssl.keyStoreType', 'JKS', 'The type of the key-store.', 12),
('spark.ssl.needClientAuth', 'FALSE', 'Set true if SSL needs client authentication.', 12),
('spark.ssl.protocol', 'None', 'A protocol name. The protocol must be supported by JVM. The reference list of protocols one can find on?this?page.', 12),
('spark.ssl.trustStore', 'None', 'A path to a trust-store file. The path can be absolute or relative to the directory where the component is started in.', 12),
('spark.ssl.trustStorePassword', 'None', 'A password to the trust-store.', 12),
('spark.ssl.trustStoreType', 'JKS', 'The type of the trust-store.', 12),
('spark.stage.maxConsecutiveAttempts', '4', 'Number of consecutive stage attempts allowed before a stage is aborted.', 9),
('spark.storage.memoryFraction', '0.6', '(deprecated) This is read only if?spark.memory.useLegacyMode?is enabled. Fraction of Java heap to use for Spark\'s memory cache. This should not be larger than the \"old\" generation of objects in the JVM, which by default is given 0.6 of the heap, but you can increase it if you configure your own old generation size.', 6),
('spark.storage.memoryMapThreshold', '2m', 'Size in bytes of a block above which Spark memory maps when reading a block from disk. This prevents Spark from memory mapping very small blocks. In general, memory mapping has high overhead for blocks close to or below the page size of the operating system.', 7),
('spark.storage.replication.proactive', 'FALSE', 'Enables proactive block replication for RDD blocks. Cached RDD block replicas lost due to executor failures are replenished if there are any existing available replicas. This tries to get the replication level of the block to the initial number.', 6),
('spark.storage.unrollFraction', '0.2', '(deprecated) This is read only if?spark.memory.useLegacyMode?is enabled. Fraction of?spark.storage.memoryFraction?to use for unrolling blocks in memory. This is dynamically allocated by dropping existing blocks when there is not enough free storage space to unroll the new block in its entirety.', 6),
('spark.streaming.backpressure.enabled', 'FALSE', 'Enables or disables Spark Streaming\'s internal backpressure mechanism (since 1.5). This enables the Spark Streaming to control the receiving rate based on the current batch scheduling delays and processing times so that the system receives only as fast as the system can process. Internally, this dynamically sets the maximum receiving rate of receivers. This rate is upper bounded by the valuesspark.streaming.receiver.maxRate?and?spark.streaming.kafka.maxRatePerPartition?if they are set (see below).', 14),
('spark.streaming.backpressure.initialRate', 'not set', 'This is the initial maximum receiving rate at which each receiver will receive data for the first batch when the backpressure mechanism is enabled.', 14),
('spark.streaming.blockInterval', '200ms', 'Interval at which data received by Spark Streaming receivers is chunked into blocks of data before storing them in Spark. Minimum recommended - 50 ms. See the?performance tuningsection in the Spark Streaming programing guide for more details.', 14),
('spark.streaming.driver.writeAheadLog.closeFileAfterWrite', 'FALSE', 'Whether to close the file after writing a write ahead log record on the driver. Set this to \'true\' when you want to use S3 (or any file system that does not support flushing) for the metadata WAL on the driver.', 14),
('spark.streaming.kafka.maxRatePerPartition', 'not set', 'Maximum rate (number of records per second) at which data will be read from each Kafka partition when using the new Kafka direct stream API. See the?Kafka Integration guide?for more details.', 14),
('spark.streaming.kafka.maxRetries', '1', 'Maximum number of consecutive retries the driver will make in order to find the latest offsets on the leader of each partition (a default value of 1 means that the driver will make a maximum of 2 attempts). Only applies to the new Kafka direct stream API.', 14),
('spark.streaming.receiver.maxRate', 'not set', 'Maximum rate (number of records per second) at which each receiver will receive data. Effectively, each stream will consume at most this number of records per second. Setting this configuration to 0 or a negative number will put no limit on the rate. See the?deployment guide?in the Spark Streaming programing guide for mode details.', 14),
('spark.streaming.receiver.writeAheadLog.closeFileAfterWrite', 'FALSE', 'Whether to close the file after writing a write ahead log record on the receivers. Set this to \'true\' when you want to use S3 (or any file system that does not support flushing) for the data WAL on the receivers.', 14),
('spark.streaming.receiver.writeAheadLog.enable', 'FALSE', 'Enable write ahead logs for receivers. All the input data received through receivers will be saved to write ahead logs that will allow it to be recovered after driver failures. See the?deployment guide?in the Spark Streaming programing guide for more details.', 14),
('spark.streaming.stopGracefullyOnShutdown', 'FALSE', 'If?true, Spark shuts down the?StreamingContext?gracefully on JVM shutdown rather than immediately.', 14),
('spark.streaming.ui.retainedBatches', '1000', 'How many batches the Spark Streaming UI and status APIs remember before garbage collecting.', 14),
('spark.streaming.unpersist', 'TRUE', 'Force RDDs generated and persisted by Spark Streaming to be automatically unpersisted from Spark\'s memory. The raw input data received by Spark Streaming is also automatically cleared. Setting this to false will allow the raw data and persisted RDDs to be accessible outside the streaming application as they will not be cleared automatically. But it comes at the cost of higher memory usage in Spark.', 14),
('spark.submit.deployMode', '(none)', 'The deploy mode of Spark driver program, either \"client\" or \"cluster\", Which means to launch driver program locally (\"client\") or remotely (\"cluster\") on one of the nodes inside the cluster.', 1),
('spark.submit.pyFiles', '', 'Comma-separated list of .zip, .egg, or .py files to place on the PYTHONPATH for Python apps. Globs are allowed.', 2),
('spark.task.cpus', '1', 'Number of cores to allocate for each task.', 9),
('spark.task.maxFailures', '4', 'Number of failures of any particular task before giving up on the job. The total number of failures spread across different tasks will not cause the job to fail; a particular task has to fail this number of attempts. Should be greater than or equal to 1. Number of allowed retries = this value - 1.', 9),
('spark.task.reaper.enabled', 'FALSE', 'Enables monitoring of killed / interrupted tasks. When set to true, any task which is killed will be monitored by the executor until that task actually finishes executing. See the other?spark.task.reaper.*?configurations for details on how to control the exact behavior of this monitoring. When set to false (the default), task killing will use an older code path which lacks such monitoring.', 9),
('spark.task.reaper.killTimeout', '-1', 'When?spark.task.reaper.enabled = true, this setting specifies a timeout after which the executor JVM will kill itself if a killed task has not stopped running. The default value, -1, disables this mechanism and prevents the executor from self-destructing. The purpose of this setting is to act as a safety-net to prevent runaway uncancellable tasks from rendering an executor unusable.', 9),
('spark.task.reaper.pollingInterval', '10s', 'When?spark.task.reaper.enabled = true, this setting controls the frequency at which executors will poll the status of killed tasks. If a killed task is still running when polled then a warning will be logged and, by default, a thread-dump of the task will be logged (this thread dump can be disabled via the?spark.task.reaper.threadDumpsetting, which is documented below).', 9);
INSERT INTO `conf` (`conf_name`, `default_value`, `conf_desc`, `conf_type`) VALUES
('spark.task.reaper.threadDump', 'TRUE', 'When?spark.task.reaper.enabled = true, this setting controls whether task thread dumps are logged during periodic polling of killed tasks. Set this to false to disable collection of thread dumps.', 9),
('spark.ui.enabled', 'TRUE', 'Whether to run the web UI for the Spark application.', 4),
('spark.ui.filters', 'None', 'Comma separated list of filter class names to apply to the Spark web UI. The filter should be a standard?javax servlet Filter. Parameters to each filter can also be specified by setting a java system property of:?\nspark.<class name of filter>.params=\'param1=value1,param2=value2\'\nFor example:?\n-Dspark.ui.filters=com.test.filter1?\n-Dspark.com.test.filter1.params=\'param1=foo,param2=testing\'', 11),
('spark.ui.killEnabled', 'TRUE', 'Allows jobs and stages to be killed from the web UI.', 4),
('spark.ui.port', '4040', 'Port for your application\'s dashboard, which shows memory and workload data.', 4),
('spark.ui.retainedDeadExecutors', '100', 'How many dead executors the Spark UI and status APIs remember before garbage collecting.', 4),
('spark.ui.retainedJobs', '1000', 'How many jobs the Spark UI and status APIs remember before garbage collecting. This is a target maximum, and fewer elements may be retained in some circumstances.', 4),
('spark.ui.retainedStages', '1000', 'How many stages the Spark UI and status APIs remember before garbage collecting. This is a target maximum, and fewer elements may be retained in some circumstances.', 4),
('spark.ui.retainedTasks', '100000', 'How many tasks the Spark UI and status APIs remember before garbage collecting. This is a target maximum, and fewer elements may be retained in some circumstances.', 4),
('spark.ui.reverseProxy', 'FALSE', 'Enable running Spark Master as reverse proxy for worker and application UIs. In this mode, Spark master will reverse proxy the worker and application UIs to enable access without requiring direct access to their hosts. Use it with caution, as worker and application UI will not be accessible directly, you will only be able to access them through spark master/proxy public URL. This setting affects all the workers and application UIs running in the cluster and must be set on all the workers, drivers and masters.', 4),
('spark.ui.reverseProxyUrl', '', 'This is the URL where your proxy is running. This URL is for proxy which is running in front of Spark Master. This is useful when running proxy for authentication e.g. OAuth proxy. Make sure this is a complete URL including scheme (http/https) and port to reach your proxy.', 4),
('spark.ui.showConsoleProgress', 'TRUE', 'Show the progress bar in the console. The progress bar shows the progress of stages that run for longer than 500ms. If multiple stages run at the same time, multiple progress bars will be displayed on the same line.', 4),
('spark.ui.view.acls', 'Empty', 'Comma separated list of users that have view access to the Spark web ui. By default only the user that started the Spark job has view access. Putting a \"*\" in the list means any user can have view access to this Spark job.', 11),
('spark.ui.view.acls.groups', 'Empty', 'Comma separated list of groups that have view access to the Spark web ui to view the Spark Job details. This can be used if you have a set of administrators or developers or users who can monitor the Spark job submitted. Putting a \"*\" in the list means any user in any group can view the Spark job details on the Spark web ui. The user groups are obtained from the instance of the groups mapping provider specified by?spark.user.groups.mapping. Check the entry?spark.user.groups.mapping?for more details.', 11),
('spark.user.groups.mapping', 'org.apache.spark.security.ShellBasedGroupsMappingProvider', 'The list of groups for a user is determined by a group mapping service defined by the trait org.apache.spark.security.GroupMappingServiceProvider which can be configured by this property. A default unix shell based implementation is provided?org.apache.spark.security.ShellBasedGroupsMappingProviderwhich can be specified to resolve a list of groups for a user.?Note:This implementation supports only a Unix/Linux based environment. Windows environment is currently?not?supported. However, a new platform/protocol can be supported by implementing the trait?org.apache.spark.security.GroupMappingServiceProvider.', 11),
('spark.worker.ui.retainedDrivers', '1000', 'How many finished drivers the Spark UI and status APIs remember before garbage collecting.', 4),
('spark.worker.ui.retainedExecutors', '1000', 'How many finished executors the Spark UI and status APIs remember before garbage collecting.', 4),
('spark.yarn.access.hadoopFileSystems', '(none)', 'A comma-separated list of secure Hadoop filesystems your Spark application is going to access. For example,?spark.yarn.access.hadoopFileSystems=hdfs://nn1.com:8032,hdfs://nn2.com:8032, webhdfs://nn3.com:50070. The Spark application must have access to the filesystems listed and Kerberos must be properly configured to be able to access them (either in the same realm or in a trusted realm). Spark acquires security tokens for each of the filesystems so that the Spark application can access those remote Hadoop filesystems.?spark.yarn.access.namenodes?is deprecated, please use this instead.', 18),
('spark.yarn.am.attemptFailuresValidityInterval', '(none)', 'Defines the validity interval for AM failure tracking. If the AM has been running for at least the defined interval, the AM failure count will be reset. This feature is not enabled if not configured.', 18),
('spark.yarn.am.cores', '1', 'Number of cores to use for the YARN Application Master in client mode. In cluster mode, use?spark.driver.cores?instead.', 18),
('spark.yarn.am.extraJavaOptions', '(none)', 'A string of extra JVM options to pass to the YARN Application Master in client mode. In cluster mode, use?spark.driver.extraJavaOptions?instead. Note that it is illegal to set maximum heap size (-Xmx) settings with this option. Maximum heap size settings can be set with?spark.yarn.am.memory', 18),
('spark.yarn.am.extraLibraryPath', '(none)', 'Set a special library path to use when launching the YARN Application Master in client mode.', 18),
('spark.yarn.am.memory', '512m', 'Amount of memory to use for the YARN Application Master in client mode, in the same format as JVM memory strings (e.g.?512m,?2g). In cluster mode, use?spark.driver.memory?instead.\nUse lower-case suffixes, e.g.?k,?m,?g,?t, and?p, for kibi-, mebi-, gibi-, tebi-, and pebibytes, respectively.', 18),
('spark.yarn.am.memoryOverhead', 'AM memory * 0.10, with minimum of 384', 'Same as?spark.driver.memoryOverhead, but for the YARN Application Master in client mode.', 18),
('spark.yarn.am.nodeLabelExpression', '(none)', 'A YARN node label expression that restricts the set of nodes AM will be scheduled on. Only versions of YARN greater than or equal to 2.6 support node label expressions, so when running against earlier versions, this property will be ignored.', 18),
('spark.yarn.am.waitTime', '100s', 'In?cluster?mode, time for the YARN Application Master to wait for the SparkContext to be initialized. In?client?mode, time for the YARN Application Master to wait for the driver to connect to it.', 18),
('spark.yarn.appMasterEnv.[EnvironmentVariableName]', '(none)', 'Add the environment variable specified by?EnvironmentVariableName?to the Application Master process launched on YARN. The user can specify multiple of these and to set multiple environment variables. In?cluster?mode this controls the environment of the Spark driver and in?client?mode it only controls the environment of the executor launcher.', 18),
('spark.yarn.archive', '(none)', 'An archive containing needed Spark jars for distribution to the YARN cache. If set, this configuration replaces?spark.yarn.jars?and the archive is used in all the application\'s containers. The archive should contain jar files in its root directory. Like with the previous option, the archive can also be hosted on HDFS to speed up file distribution.', 18),
('spark.yarn.config.gatewayPath', '(none)', 'A path that is valid on the gateway host (the host where a Spark application is started) but may differ for paths for the same resource in other nodes in the cluster. Coupled with?spark.yarn.config.replacementPath, this is used to support clusters with heterogeneous configurations, so that Spark can correctly launch remote processes.\nThe replacement path normally will contain a reference to some environment variable exported by YARN (and, thus, visible to Spark containers).\nFor example, if the gateway node has Hadoop libraries installed on?/disk1/hadoop, and the location of the Hadoop install is exported by YARN as the?HADOOP_HOME?environment variable, setting this value to?/disk1/hadoop?and the replacement path to?$HADOOP_HOMEwill make sure that paths used to launch remote processes properly reference the local YARN configuration.', 18),
('spark.yarn.config.replacementPath', '(none)', 'See?spark.yarn.config.gatewayPath.', 18),
('spark.yarn.containerLauncherMaxThreads', '25', 'The maximum number of threads to use in the YARN Application Master for launching executor containers.', 18),
('spark.yarn.dist.archives', '(none)', 'Comma separated list of archives to be extracted into the working directory of each executor.', 18),
('spark.yarn.dist.files', '(none)', 'Comma-separated list of files to be placed in the working directory of each executor.', 18),
('spark.yarn.dist.forceDownloadSchemes', '(none)', 'Comma-separated list of schemes for which files will be downloaded to the local disk prior to being added to YARN\'s distributed cache. For use in cases where the YARN service does not support schemes that are supported by Spark, like http, https and ftp.', 18),
('spark.yarn.dist.jars', '(none)', 'Comma-separated list of jars to be placed in the working directory of each executor.', 18),
('spark.yarn.executor.failuresValidityInterval', '(none)', 'Defines the validity interval for executor failure tracking. Executor failures which are older than the validity interval will be ignored.', 18),
('spark.yarn.executor.nodeLabelExpression', '(none)', 'A YARN node label expression that restricts the set of nodes executors will be scheduled on. Only versions of YARN greater than or equal to 2.6 support node label expressions, so when running against earlier versions, this property will be ignored.', 18),
('spark.yarn.historyServer.address', '(none)', 'The address of the Spark history server, e.g.?host.com:18080. The address should not contain a scheme (http://). Defaults to not being set since the history server is an optional service. This address is given to the YARN ResourceManager when the Spark application finishes to link the application from the ResourceManager UI to the Spark history server UI. For this property, YARN properties can be used as variables, and these are substituted by Spark at runtime. For example, if the Spark history server runs on the same node as the YARN ResourceManager, it can be set to?${hadoopconf-yarn.resourcemanager.hostname}:18080.', 18),
('spark.yarn.jars', '(none)', 'List of libraries containing Spark code to distribute to YARN containers. By default, Spark on YARN will use Spark jars installed locally, but the Spark jars can also be in a world-readable location on HDFS. This allows YARN to cache it on nodes so that it doesn\'t need to be distributed each time an application runs. To point to jars on HDFS, for example, set this configuration to?hdfs:///some/path. Globs are allowed.', 18),
('spark.yarn.kerberos.relogin.period', '1m', 'How often to check whether the kerberos TGT should be renewed. This should be set to a value that is shorter than the TGT renewal period (or the TGT lifetime if TGT renewal is not enabled). The default value should be enough for most deployments.', 18),
('spark.yarn.keytab', '(none)', 'The full path to the file that contains the keytab for the principal specified above. This keytab will be copied to the node running the YARN Application Master via the Secure Distributed Cache, for renewing the login tickets and the delegation tokens periodically. (Works also with the \"local\" master)', 18),
('spark.yarn.max.executor.failures', 'numExecutors * 2, with minimum of 3', 'The maximum number of executor failures before failing the application.', 18),
('spark.yarn.maxAppAttempts', 'yarn.resourcemanager.am.max-attempts?in YARN', 'The maximum number of attempts that will be made to submit the application. It should be no larger than the global number of max attempts in the YARN configuration.', 18),
('spark.yarn.preserve.staging.files', 'FALSE', 'Set to?true?to preserve the staged files (Spark jar, app jar, distributed cache files) at the end of the job rather than delete them.', 18),
('spark.yarn.principal', '(none)', 'Principal to be used to login to KDC, while running on secure HDFS. (Works also with the \"local\" master)', 18),
('spark.yarn.queue', 'default', 'The name of the YARN queue to which the application is submitted.', 18),
('spark.yarn.rolledLog.excludePattern', '(none)', 'Java Regex to filter the log files which match the defined exclude pattern and those log files will not be aggregated in a rolling fashion. If the log file name matches both the include and the exclude pattern, this file will be excluded eventually.', 18),
('spark.yarn.rolledLog.includePattern', '(none)', 'Java Regex to filter the log files which match the defined include pattern and those log files will be aggregated in a rolling fashion. This will be used with YARN\'s rolling log aggregation, to enable this feature in YARN side?yarn.nodemanager.log-aggregation.roll-monitoring-interval-seconds?should be configured in yarn-site.xml. This feature can only be used with Hadoop 2.6.4+. The Spark log4j appender needs be changed to use FileAppender or another appender that can handle the files being removed while it is running. Based on the file name configured in the log4j configuration (like spark.log), the user should set the regex (spark*) to include all the log files that need to be aggregated.', 18),
('spark.yarn.scheduler.heartbeat.interval-ms', '3000', 'The interval in ms in which the Spark application master heartbeats into the YARN ResourceManager. The value is capped at half the value of YARN\'s configuration for the expiry interval, i.e.?yarn.am.liveness-monitor.expiry-interval-ms.', 18),
('spark.yarn.scheduler.initial-allocation.interval', '200ms', 'The initial interval in which the Spark application master eagerly heartbeats to the YARN ResourceManager when there are pending container allocation requests. It should be no larger than?spark.yarn.scheduler.heartbeat.interval-ms. The allocation interval will doubled on successive eager heartbeats if pending containers still exist, untilspark.yarn.scheduler.heartbeat.interval-ms?is reached.', 18),
('spark.yarn.shuffle.stopOnFailure', 'false', 'Whether to stop the NodeManager when there\'s a failure in the Spark Shuffle Service\'s initialization. This prevents application failures caused by running containers on NodeManagers where the Spark Shuffle Service is not running.', 18),
('spark.yarn.stagingDir', 'Current user\'s home directory in the filesystem', 'Staging directory used while submitting applications.', 18),
('spark.yarn.submit.file.replication', 'The default HDFS replication (usually?3)', 'HDFS replication level for the files uploaded into HDFS for the application. These include things like the Spark jar, the app jar, and any distributed cache files/archives.', 18),
('spark.yarn.submit.waitAppCompletion', 'TRUE', 'In YARN cluster mode, controls whether the client waits to exit until the application completes. If set to?true, the client process will stay alive reporting the application\'s status. Otherwise, the client process will exit after submission.', 18),
('spark.yarn.tags', '(none)', 'Comma-separated list of strings to pass through as YARN application tags appearing in YARN ApplicationReports, which can be used for filtering when querying YARN apps.', 18);

--
-- Indexes for dumped tables
--

--
-- Indexes for table `conf`
--
ALTER TABLE `conf`
  ADD PRIMARY KEY (`conf_name`);
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
